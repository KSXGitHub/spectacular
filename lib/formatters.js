// Generated by CoffeeScript 1.6.2
var fs, util, utils;

fs = require('fs');

util = require('util');

utils = require('./utils');

exports.StackFormatter = (function() {
  function StackFormatter(error, options) {
    this.error = error;
    this.options = options;
  }

  StackFormatter.prototype.format = function() {
    var res, stack;

    stack = this.error.stack.split('\n').filter(function(line) {
      return /^\s{4}at.*$/g.test(line);
    });
    res = '\n';
    try {
      if (this.options.showSource) {
        res += this.formatErrorInFile(stack[0]);
      }
    } catch (_error) {}
    if (this.options.longTrace) {
      res += "\n\n" + (stack.join('\n')) + "\n";
    } else {
      res += "\n" + (stack.slice(0, 6).concat("    ...\n\n    use --long-trace option to view the " + (stack.length - 6) + " remaining lines").join('\n')) + "\n\n";
    }
    if (!this.options.noColors) {
      res = res.grey;
    }
    return res;
  };

  StackFormatter.prototype.formatErrorInFile = function(line) {
    var column, file, match, re, _ref;

    re = /\((.*):(.*):(.*)\)/;
    if (!re.test(line)) {
      return '';
    }
    _ref = re.exec(line), match = _ref[0], file = _ref[1], line = _ref[2], column = _ref[3];
    return "\n" + (this.getLines(file, parseInt(line), parseInt(column))) + "\n";
  };

  StackFormatter.prototype.getLines = function(file, line, column) {
    var compile, endLine, fileContent, lines, startLine,
      _this = this;

    fileContent = fs.readFileSync(file).toString();
    if (this.options.coffee && file.indexOf('.coffee') !== -1) {
      compile = require('coffee-script').compile;
      fileContent = compile(fileContent, {
        bare: true
      });
    }
    fileContent = fileContent.split('\n').map(function(l, i) {
      return "    " + (utils.padRight(i + 1)) + " | " + l;
    });
    this.insertColumnLine(fileContent, line, column);
    startLine = Math.max(1, line - 3) - 1;
    endLine = Math.min(fileContent.length, line + 2) - 1;
    lines = fileContent.slice(startLine, +endLine + 1 || 9e9).join('\n');
    return lines;
  };

  StackFormatter.prototype.insertColumnLine = function(content, line, column) {
    if (line === content.length) {
      return content.push(line);
    } else {
      return content.splice(line, 0, "         |" + (utils.padRight('^', column - 2)));
    }
  };

  return StackFormatter;

})();

exports.ResultsFormatter = (function() {
  function ResultsFormatter(root, options, env) {
    this.root = root;
    this.options = options;
    this.env = env;
    this.errorsCounter = 1;
    this.failuresCounter = 1;
    this.errors = [];
    this.failures = [];
    this.skipped = [];
    this.pending = [];
    this.results = [];
    this.examples = [];
  }

  ResultsFormatter.prototype.registerResult = function(example) {
    this.printExampleResult(example);
    this.results.push(example.result);
    return this.examples.push(example);
  };

  ResultsFormatter.prototype.hasFailures = function() {
    return this.results.some(function(result) {
      var _ref;

      return (_ref = result.state) === 'failure' || _ref === 'skipped' || _ref === 'errored';
    });
  };

  ResultsFormatter.prototype.printResults = function(lstart, lend, sstart, send) {
    return console.log(this.buildResults(lstart, lend, sstart, send));
  };

  ResultsFormatter.prototype.buildResults = function(lstart, lend, sstart, send) {
    var expectation, res, result, _i, _j, _len, _len1, _ref, _ref1;

    res = '\n\n';
    _ref = this.results;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      result = _ref[_i];
      switch (result.state) {
        case 'pending':
          this.pending.push(result.example);
          break;
        case 'skipped':
          this.skipped.push(result.example);
          break;
        case 'errored':
          this.errors.push(result.example);
          res += this.formatExampleError(result.example);
          break;
        case 'failure':
          this.failures.push(result.example);
          if (result.expectations.length > 0) {
            _ref1 = result.expectations;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              expectation = _ref1[_j];
              if (!expectation.success) {
                res += this.formatExpectationFailure(expectation);
              }
            }
          } else {
            res += this.formatExampleFailure(result.example);
          }
      }
    }
    res += this.formatResume();
    res += this.formatTimers(lstart, lend, sstart, send);
    res += this.formatCounters();
    return res += '\n';
  };

  ResultsFormatter.prototype.printExampleResult = function(example) {
    var res;

    res = this.formatExampleResult(example);
    if (res != null) {
      return util.print(res);
    }
  };

  ResultsFormatter.prototype.formatExampleResult = function(example) {
    if (this.options.noColors) {
      switch (example.result.state) {
        case 'pending':
          return '*';
        case 'skipped':
          return 'x';
        case 'failure':
          return 'F';
        case 'errored':
          return 'E';
        case 'success':
          return '.';
      }
    } else {
      switch (example.result.state) {
        case 'pending':
          return '*'.yellow;
        case 'skipped':
          return 'x'.magenta;
        case 'failure':
          return 'F'.red;
        case 'errored':
          return 'E'.yellow;
        case 'success':
          return '.'.green;
      }
    }
  };

  ResultsFormatter.prototype.formatStack = function(e) {
    return new exports.StackFormatter(e, this.options).format();
  };

  ResultsFormatter.prototype.formatExampleFailure = function(example) {
    var res;

    res = this.failureBadge(example.description);
    res += this.formatError(example.examplePromise.reason);
    return res += '\n';
  };

  ResultsFormatter.prototype.formatExpectationFailure = function(expectation) {
    var res;

    res = this.failureBadge(expectation.description);
    res += '\n';
    res += this.formatMessage(expectation.message);
    if (this.options.trace) {
      res += this.formatStack(expectation.trace);
    }
    return res += '\n';
  };

  ResultsFormatter.prototype.formatExampleError = function(example) {
    var res;

    res = this.errorBadge(example.description);
    return res += this.formatError(example.examplePromise.reason);
  };

  ResultsFormatter.prototype.formatError = function(error) {
    var res;

    res = this.formatMessage(error.message);
    if (this.options.trace) {
      return res += this.formatStack(error);
    }
  };

  ResultsFormatter.prototype.failureBadge = function(message) {
    var badge;

    badge = ' FAIL ';
    if (this.options.noColors) {
      return "" + badge + " " + message + "\n";
    } else {
      return ("" + badge.inverse.bold + "[" + (this.failuresCounter++) + "] " + message + "\n").red;
    }
  };

  ResultsFormatter.prototype.errorBadge = function(message) {
    var badge;

    badge = ' ERROR ';
    if (this.options.noColors) {
      return "" + badge + " " + message + "\n";
    } else {
      return ("" + badge.inverse.bold + "[" + (this.errorsCounter++) + "] " + message + "\n").yellow;
    }
  };

  ResultsFormatter.prototype.formatMessage = function(message) {
    return "\n" + (utils.indent(message || ''));
  };

  ResultsFormatter.prototype.formatResume = function() {
    var res;

    res = '';
    if (this.errors.length > 0) {
      res += this.mapDescription('Errors:', this.errors, 'yellow');
    }
    if (this.failures.length > 0) {
      res += this.mapDescription('Failures:', this.failures, 'red');
    }
    if (this.skipped.length > 0) {
      res += this.mapDescription('Skipped:', this.skipped, 'magenta');
    }
    if (this.pending.length > 0) {
      res += this.mapDescription('Pending:', this.pending, 'yellow');
    }
    return res;
  };

  ResultsFormatter.prototype.mapDescription = function(desc, array, color) {
    var res;

    res = "    " + desc + "\n\n";
    res += array.map(function(e, i) {
      return "      " + (i + 1) + ". " + e.description;
    }).join('\n');
    if (!this.options.noColors) {
      res = res[color];
    }
    return "" + res + "\n\n";
  };

  ResultsFormatter.prototype.formatTimers = function(loadStartedAt, loadEndedAt, specsStartedAt, specsEndedAt) {
    var loadDuration, specsDuration;

    loadDuration = this.formatDuration(loadStartedAt, loadEndedAt);
    specsDuration = this.formatDuration(specsStartedAt, specsEndedAt);
    return "Specs loaded in " + loadDuration + "\nFinished in " + specsDuration + "\n";
  };

  ResultsFormatter.prototype.formatCounters = function() {
    var assertions, errored, failures, pending, skipped, success;

    failures = this.failures.length;
    errored = this.errors.length;
    skipped = this.skipped.length;
    pending = this.pending.length;
    success = this.examples.length - failures - errored - pending - skipped;
    assertions = this.results.reduce((function(a, b) {
      return a + b.expectations.length;
    }), 0);
    return this.formatResults(success, failures, errored, skipped, pending, assertions);
  };

  ResultsFormatter.prototype.formatResults = function(s, f, e, sk, p, a) {
    var toggle;

    toggle = utils.toggle;
    return utils.squeeze("" + (this.formatCount(s, 'success', 'success', toggle(f, 'green'))) + ",    " + (this.formatCount(a, 'assertion', 'assertions', toggle(f, 'green'))) + ",    " + (this.formatCount(f, 'failure', 'failures', toggle(f, 'green', 'red'))) + ",    " + (this.formatCount(e, 'error', 'errors', toggle(e, 'green', 'yellow'))) + ",    " + (this.formatCount(sk, 'skipped', 'skipped', toggle(sk, 'green', 'magenta'))) + ",    " + (this.formatCount(p, 'pending', 'pending', toggle(p, 'green', 'yellow'))));
  };

  ResultsFormatter.prototype.formatDuration = function(start, end) {
    var duration;

    duration = (end.getTime() - start.getTime()) / 1000;
    duration = "" + (Math.max(0, duration)) + "s";
    if (!this.options.noColors) {
      duration = duration.yellow;
    }
    return duration;
  };

  ResultsFormatter.prototype.formatCount = function(value, singular, plural, color) {
    var s;

    s = "" + value + " " + (value === 0 ? plural : value === 1 ? singular : plural);
    if ((color != null) && !this.options.noColors) {
      s = s[color];
    }
    return s;
  };

  return ResultsFormatter;

})();
