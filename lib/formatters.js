// Generated by CoffeeScript 1.6.2
var fs, util, utils;

fs = require('fs');

util = require('util');

utils = require('./utils');

exports.StackFormatter = (function() {
  function StackFormatter(error, options) {
    this.error = error;
    this.options = options;
  }

  StackFormatter.prototype.print = function() {
    var res, stack;

    stack = this.error.stack.split('\n').filter(function(line) {
      return /^\s{4}at.*$/g.test(line);
    });
    if (this.options.showSource) {
      this.printErrorInFile(stack[0]);
    }
    if (this.options.longTrace) {
      res = "\n\n" + (stack.join('\n'));
    } else {
      res = "\n" + (stack.slice(0, 6).concat("    ...\n\n    use --long-trace option to view the " + (stack.length - 6) + " remaining lines").join('\n'));
    }
    if (!this.options.noColors) {
      res = res.grey;
    }
    if (res.substr(-1) !== '\n') {
      res = "" + res + "\n";
    }
    return console.log(res);
  };

  StackFormatter.prototype.printErrorInFile = function(line) {
    var column, file, match, re, _ref;

    re = /\((.*):(.*):(.*)\)/;
    _ref = re.exec(line), match = _ref[0], file = _ref[1], line = _ref[2], column = _ref[3];
    console.log('');
    return console.log(this.getLines(file, parseInt(line), parseInt(column)));
  };

  StackFormatter.prototype.getLines = function(file, line, column) {
    var compile, endLine, fileContent, lines, startLine,
      _this = this;

    fileContent = fs.readFileSync(file).toString();
    if (this.options.coffee && file.indexOf('.coffee') !== -1) {
      compile = require('coffee-script').compile;
      fileContent = compile(fileContent, {
        bare: true
      });
    }
    fileContent = fileContent.split('\n').map(function(l, i) {
      return "    " + (utils.padRight(i + 1)) + " | " + l;
    });
    this.insertColumnLine(fileContent, line, column);
    startLine = Math.max(1, line - 3) - 1;
    endLine = Math.min(fileContent.length, line + 2) - 1;
    lines = fileContent.slice(startLine, +endLine + 1 || 9e9).join('\n');
    if (!this.options.noColors) {
      lines = lines.grey;
    }
    return lines;
  };

  StackFormatter.prototype.insertColumnLine = function(content, line, column) {
    if (line === content.length) {
      return content.push(line);
    } else {
      return content.splice(line, 0, "         |" + (utils.padRight('^', column - 2)));
    }
  };

  return StackFormatter;

})();

exports.ResultsFormatter = (function() {
  function ResultsFormatter(root, options, env) {
    this.root = root;
    this.options = options;
    this.env = env;
    this.results = [];
    this.examples = [];
  }

  ResultsFormatter.prototype.registerResult = function(example) {
    this.printExampleResult(example);
    this.results.push(example.result);
    return this.examples.push(example);
  };

  ResultsFormatter.prototype.hasFailures = function() {
    return this.results.some(function(result) {
      var _ref;

      return (_ref = result.state) === 'failure' || _ref === 'skipped' || _ref === 'errored';
    });
  };

  ResultsFormatter.prototype.printExampleResult = function(example) {
    if (this.options.noColors) {
      switch (example.result.state) {
        case 'pending':
          return util.print('*');
        case 'skipped':
          return util.print('x');
        case 'failure':
          return util.print('F');
        case 'errored':
          return util.print('E');
        case 'success':
          return util.print('.');
      }
    } else {
      switch (example.result.state) {
        case 'pending':
          return util.print('*'.yellow);
        case 'skipped':
          return util.print('x'.magenta);
        case 'failure':
          return util.print('F'.red);
        case 'errored':
          return util.print('E'.yellow);
        case 'success':
          return util.print('.'.green);
      }
    }
  };

  ResultsFormatter.prototype.printStack = function(e) {
    return new exports.StackFormatter(e, this.options).print();
  };

  ResultsFormatter.prototype.printExampleFailure = function(example) {
    var message;

    message = example.description;
    console.log(this.failureBadge(message));
    this.printError(example.examplePromise.reason);
    return console.log('\n');
  };

  ResultsFormatter.prototype.printExpectationFailure = function(expectation) {
    var message;

    message = expectation.description;
    console.log(this.failureBadge(message));
    this.printMessage(expectation.message);
    if (this.options.trace) {
      this.printStack(expectation.trace);
    }
    return console.log('\n');
  };

  ResultsFormatter.prototype.printExampleError = function(example) {
    var message;

    message = example.description;
    console.log(this.errorBadge(message));
    return this.printError(example.examplePromise.reason);
  };

  ResultsFormatter.prototype.printError = function(error) {
    this.printMessage(error.message);
    if (this.options.trace) {
      return this.printStack(error);
    }
  };

  ResultsFormatter.prototype.failureBadge = function(message) {
    var badge;

    badge = ' FAIL ';
    if (this.options.noColors) {
      return "" + badge + " " + message;
    } else {
      return ("" + badge.inverse.bold + " " + message).red;
    }
  };

  ResultsFormatter.prototype.errorBadge = function(message) {
    var badge;

    badge = ' ERROR ';
    if (this.options.noColors) {
      return "" + badge + " " + message;
    } else {
      return ("" + badge.inverse.bold + " " + message).yellow;
    }
  };

  ResultsFormatter.prototype.printMessage = function(message) {
    return console.log("\n" + (utils.indent(message)));
  };

  ResultsFormatter.prototype.printResults = function(lstart, lend, sstart, send) {
    var expectation, result, _i, _j, _len, _len1, _ref, _ref1;

    console.log('\n');
    if (this.hasFailures()) {
      _ref = this.results;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        result = _ref[_i];
        switch (result.state) {
          case 'errored':
            this.printExampleError(result.example);
            break;
          case 'failure':
            if (result.expectations.length > 0) {
              _ref1 = result.expectations;
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                expectation = _ref1[_j];
                if (!expectation.success) {
                  this.printExpectationFailure(expectation);
                }
              }
            } else {
              this.printExampleFailure(result.example);
              console.log('\n');
            }
        }
      }
    }
    console.log(this.formatTimers(lstart, lend, sstart, send));
    console.log(this.formatCounters());
    return console.log('');
  };

  ResultsFormatter.prototype.formatTimers = function(loadStartedAt, loadEndedAt, specsStartedAt, specsEndedAt) {
    var loadDuration, specsDuration;

    loadDuration = this.formatDuration(loadStartedAt, loadEndedAt);
    specsDuration = this.formatDuration(specsStartedAt, specsEndedAt);
    return "Specs loaded in " + loadDuration + "\nFinished in " + specsDuration;
  };

  ResultsFormatter.prototype.formatCounters = function() {
    var assertions, errored, failures, pending, skipped, success;

    success = this.examples.filter(function(e) {
      return e.result.state === 'success';
    }).length;
    failures = this.examples.filter(function(e) {
      return e.result.state === 'failure';
    }).length;
    errored = this.examples.filter(function(e) {
      return e.result.state === 'errored';
    }).length;
    skipped = this.examples.filter(function(e) {
      return e.result.state === 'skipped';
    }).length;
    pending = this.examples.filter(function(e) {
      return e.result.state === 'pending';
    }).length;
    assertions = this.results.reduce((function(a, b) {
      return a + b.expectations.length;
    }), 0);
    return this.formatResults(success, failures, errored, skipped, pending, assertions);
  };

  ResultsFormatter.prototype.formatResults = function(s, f, e, sk, p, a) {
    var toggle;

    toggle = utils.toggle;
    return utils.squeeze("" + (this.formatCount(s, 'success', 'success', toggle(f, 'green'))) + ",    " + (this.formatCount(a, 'assertion', 'assertions', toggle(f, 'green'))) + ",    " + (this.formatCount(f, 'failure', 'failures', toggle(f, 'green', 'red'))) + ",    " + (this.formatCount(e, 'error', 'errors', toggle(e, 'green', 'yellow'))) + ",    " + (this.formatCount(sk, 'skipped', 'skipped', toggle(sk, 'green', 'magenta'))) + ",    " + (this.formatCount(p, 'pending', 'pending', toggle(p, 'green', 'yellow'))));
  };

  ResultsFormatter.prototype.formatDuration = function(start, end) {
    var duration;

    duration = (end.getMilliseconds() - start.getMilliseconds()) / 1000;
    duration = "" + (Math.max(0, duration)) + "s";
    if (!this.options.noColors) {
      duration = duration.yellow;
    }
    return duration;
  };

  ResultsFormatter.prototype.formatCount = function(value, singular, plural, color) {
    var s;

    s = "" + value + " " + (value === 0 ? plural : value === 1 ? singular : plural);
    if ((color != null) && !this.options.noColors) {
      s = s[color];
    }
    return s;
  };

  return ResultsFormatter;

})();
