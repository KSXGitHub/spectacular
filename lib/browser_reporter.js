// Generated by CoffeeScript 1.6.3
var BADGE_MAP, CHAR_MAP, COLOR_MAP, addClass, ancestors, currentWindowOnload, defaults, fixNodeHeight, hasClass, icon, k, removeClass, tag, toggleClass, utils, v, wrapNode, _ref,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

spectacular.formatters.browser = {};

utils = spectacular.utils;

ancestors = function(node, block) {
  var parent;
  parent = node.parentNode;
  if (hasClass(parent, 'example-group')) {
    block.call(this, parent);
    return ancestors(parent, block);
  }
};

wrapNode = function(node) {
  if (node.length != null) {
    return node;
  } else {
    return [node];
  }
};

hasClass = function(nl, cls) {
  nl = wrapNode(nl);
  return Array.prototype.every.call(nl, function(n) {
    return RegExp("(\\s|^)" + cls + "(\\s|$)").test(n.className);
  });
};

addClass = function(nl, cls) {
  nl = wrapNode(nl);
  return Array.prototype.forEach.call(nl, function(node) {
    if (!hasClass(node, cls)) {
      return node.className += " " + cls;
    }
  });
};

removeClass = function(nl, cls) {
  nl = wrapNode(nl);
  return Array.prototype.forEach.call(nl, function(node) {
    return node.className = node.className.replace(cls, '');
  });
};

toggleClass = function(nl, cls) {
  nl = wrapNode(nl);
  return Array.prototype.forEach.call(nl, function(node) {
    if (hasClass(node, cls)) {
      return removeClass(node, cls);
    } else {
      return addClass(node, cls);
    }
  });
};

fixNodeHeight = function(nl) {
  nl = wrapNode(nl);
  return Array.prototype.forEach.call(nl, function(node) {
    return node.style.height = "" + node.clientHeight + "px";
  });
};

tag = function(tag, inner, attrs, block) {
  var k, node, v, _ref;
  if (inner == null) {
    inner = '';
  }
  if (attrs == null) {
    attrs = {};
  }
  if (typeof inner === 'object') {
    _ref = ['', inner, attrs], inner = _ref[0], attrs = _ref[1], block = _ref[2];
  }
  if (typeof block === 'function') {
    inner = block();
  }
  node = document.createElement(tag);
  for (k in attrs) {
    v = attrs[k];
    node.setAttribute(k, v);
  }
  if (typeof inner === 'string') {
    node.innerHTML = inner;
  } else {
    node.appendChild(inner);
  }
  return node;
};

icon = function(icon) {
  return tag('i', {
    "class": "icon-" + icon
  });
};

spectacular.SlidingObject = (function() {
  function SlidingObject(target, container) {
    var body, doc, previousOnScroll,
      _this = this;
    this.target = target;
    this.container = container;
    previousOnScroll = window.onscroll;
    doc = document.documentElement;
    body = document.body;
    window.onscroll = function() {
      var top, topMax, topMin;
      if (previousOnScroll != null) {
        previousOnScroll();
      }
      topMin = _this.getOffset(_this.container);
      topMax = topMin + _this.container.clientHeight - _this.target.clientHeight;
      top = doc && doc.scrollTop || body && body.scrollTop || 0;
      top = Math.min(topMax, Math.max(topMin, top + 100)) - topMin;
      return _this.target.style.top = "" + top + "px";
    };
  }

  SlidingObject.prototype.getOffset = function(node) {
    if (node.nodeName.toLowerCase() === 'body') {
      return node.offsetTop;
    }
    return node.offsetTop + this.getOffset(node.parentNode);
  };

  return SlidingObject;

})();

spectacular.widgets = {};

_ref = spectacular.formatters, CHAR_MAP = _ref.CHAR_MAP, COLOR_MAP = _ref.COLOR_MAP, BADGE_MAP = _ref.BADGE_MAP;

spectacular.widgets.RunnerProgress = (function() {
  function RunnerProgress() {}

  RunnerProgress.prototype.init = function(runner) {
    var _this = this;
    this.runner = runner;
    this.container = tag('div', {
      id: 'progress'
    }, function() {
      return _this.progress = tag('span');
    });
    return document.body.appendChild(this.container);
  };

  RunnerProgress.prototype.onStart = function() {
    var c, inner, key, _results,
      _this = this;
    this.counters = {
      all: 0,
      failure: 0,
      errored: 0,
      skipped: 0,
      pending: 0,
      success: 0
    };
    this.total = this.runner.examples.length;
    this.interval = setInterval(function() {
      var t;
      t = new Date(new Date() - _this.runner.specsStartedAt);
      return _this.timeValue.textContent = "" + (t.getSeconds()) + "." + (t.getMilliseconds()) + "s";
    }, 100);
    inner = [];
    inner.push(tag('span', {
      "class": 'seed'
    }, function() {
      return icon('random').outerHTML + ' ' + tag('span', String(_this.runner.options.seed), {
        "class": 'value'
      }).outerHTML;
    }));
    inner.push(tag('span', {
      "class": 'time'
    }, function() {
      return icon('time').outerHTML + ' ' + tag('span', '0', {
        "class": 'value'
      }).outerHTML;
    }));
    inner.push(tag('span', {
      "class": 'all'
    }, function() {
      return tag('span', '0', {
        "class": 'value'
      }).outerHTML + '/' + tag('span', String(_this.total), {
        "class": 'total'
      }).outerHTML;
    }));
    for (key in CHAR_MAP) {
      c = CHAR_MAP[key];
      if (key === 'success') {
        continue;
      }
      inner.push(this[key] = tag('span', {
        "class": key
      }, function() {
        return tag('span', '0', {
          "class": 'value'
        }).outerHTML + tag('span', c, {
          "class": 'symbol'
        }).outerHTML;
      }));
    }
    this.progress.innerHTML = inner.map(function(e) {
      return e.outerHTML;
    }).join('\n');
    this.timeValue = this.progress.querySelector('.time .value');
    this.allValue = this.progress.querySelector('.all .value');
    _results = [];
    for (key in CHAR_MAP) {
      this[key] = this.progress.querySelector("." + key);
      _results.push(this[key + "Value"] = this.progress.querySelector("." + key + " .value"));
    }
    return _results;
  };

  RunnerProgress.prototype.update = function() {
    var c, key, _results;
    this.allValue.textContent = this.counters.all;
    _results = [];
    for (key in CHAR_MAP) {
      c = CHAR_MAP[key];
      if (key === 'success') {
        continue;
      }
      this["" + key + "Value"].textContent = this.counters[key];
      if (this.counters[key] && !hasClass(this[key], 'not-zero')) {
        _results.push(addClass(this[key], 'not-zero'));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  RunnerProgress.prototype.onResult = function(e) {
    var example, _ref1;
    example = e.target;
    this.counters.all++;
    this.counters[example.result.state]++;
    if ((_ref1 = example.result.state) === 'failure' || _ref1 === 'errored') {
      addClass(this.container, 'fail');
    }
    return this.update();
  };

  RunnerProgress.prototype.onEnd = function(results) {
    clearInterval(this.interval);
    if (this.counters.failure === 0 && this.counters.errored === 0) {
      return addClass(this.container, 'success');
    } else {
      return addClass(this.container, 'failure');
    }
  };

  return RunnerProgress;

})();

spectacular.BrowserReporter = (function() {
  function BrowserReporter(runner, widgets) {
    this.runner = runner;
    this.widgets = widgets;
    this.onEnd = __bind(this.onEnd, this);
    this.onResult = __bind(this.onResult, this);
    this.onStart = __bind(this.onStart, this);
    this.options = this.runner.options;
    this.registerEvents();
  }

  BrowserReporter.prototype.registerEvents = function() {
    this.runner.on('start', this.onStart);
    this.runner.on('result', this.onResult);
    return this.runner.on('end', this.onEnd);
  };

  BrowserReporter.prototype.unregisterEvents = function() {
    this.runner.off('start', this.onStart);
    this.runner.off('result', this.onResult);
    return this.runner.off('end', this.onEnd);
  };

  BrowserReporter.prototype.init = function() {
    var _this = this;
    return this.widgets.forEach(function(w) {
      return w.init(_this.runner);
    });
  };

  BrowserReporter.prototype.onStart = function(e) {
    var _this = this;
    return this.widgets.forEach(function(w) {
      return w.onStart(e);
    });
  };

  BrowserReporter.prototype.onResult = function(e) {
    return this.widgets.forEach(function(w) {
      return w.onResult(e);
    });
  };

  BrowserReporter.prototype.onEnd = function(e) {
    return this.widgets.forEach(function(w) {
      return w.onEnd(e);
    });
  };

  return BrowserReporter;

})();

spectacular.BrowserMethods = function(options) {
  var cache, loaders;
  cache = {};
  loaders = {};
  if (options.loadFile == null) {
    options.loadFile = function(file) {
      var listener, promise, req;
      promise = new spectacular.Promise;
      if (file in cache) {
        setTimeout((function() {
          return promise.resolve(cache[file]);
        }), 0);
        return promise;
      }
      if (file in loaders) {
        loaders[file].push(function(data) {
          return promise.resolve(data);
        });
        return promise;
      }
      req = new XMLHttpRequest();
      req.onload = function() {
        var data;
        data = this.responseText;
        return loaders[file].forEach(function(f) {
          return f(data);
        });
      };
      listener = function(data) {
        return promise.resolve(cache[file] = data);
      };
      loaders[file] = [listener];
      req.open('get', file, true);
      req.send();
      return promise;
    };
  }
  if (options.getOriginalSourceFor == null) {
    options.getOriginalSourceFor = function(file, line, column) {
      var fileSource, promise,
        _this = this;
      promise = new spectacular.Promise;
      fileSource = null;
      this.loadFile(this.getSourceURLFor(file)).then(function(source) {
        fileSource = source;
        return _this.loadFile(_this.getSourceMapURLFor(file));
      }).then(function(sourceMap) {
        var consumer, _ref1;
        consumer = new window.sourceMap.SourceMapConsumer(sourceMap);
        _ref1 = consumer.originalPositionFor({
          line: line,
          column: column
        }), line = _ref1.line, column = _ref1.column;
        return promise.resolve({
          content: fileSource,
          line: line,
          column: column
        });
      }).fail(function() {
        return _this.loadFile(file).then(function(content) {
          return promise.resolve({
            content: content,
            line: line,
            column: column
          });
        });
      });
      return promise;
    };
  }
  if (options.hasSourceMap == null) {
    options.hasSourceMap = function(file) {
      return false;
    };
  }
  if (options.getSourceURLFor == null) {
    options.getSourceURLFor = function(file) {};
  }
  if (options.getSourceMapURLFor == null) {
    return options.getSourceMapURLFor = function(file) {};
  }
};

spectacular.paths = spectacular.paths || [];

spectacular.options = spectacular.options || {};

defaults = {
  coffee: false,
  verbose: false,
  profile: false,
  trace: true,
  longTrace: false,
  showSource: true,
  format: 'progress',
  matchersRoot: './specs/support/matchers',
  helpersRoot: './specs/support/helpers',
  fixturesRoot: './specs/support/fixtures',
  noMatchers: false,
  noHelpers: false,
  colors: true,
  random: true,
  seed: null,
  server: false,
  globs: []
};

for (k in defaults) {
  v = defaults[k];
  if (!k in spectacular.options) {
    spectacular.options[k] = v;
  }
}

spectacular.BrowserMethods(spectacular.options);

spectacular.env = new spectacular.Environment(spectacular.options);

spectacular.env.globalize();

spectacular.env.runner.loadStartedAt = new Date();

window.env = spectacular.env;

currentWindowOnload = window.onload;

window.onload = function() {
  var reporter, s, scripts, _i, _len, _ref1;
  if (currentWindowOnload != null) {
    currentWindowOnload();
  }
  utils = spectacular.utils;
  if (spectacular.options.verbose) {
    console.log(utils.indent(utils.inspect(spectacular.options)));
    console.log(utils.indent(utils.inspect(spectacular.paths)));
    console.log('\n  Scripts loaded:');
    scripts = document.querySelectorAll('script[src]');
    for (_i = 0, _len = scripts.length; _i < _len; _i++) {
      s = scripts[_i];
      console.log("    " + ((_ref1 = s.attributes.getNamedItem("src")) != null ? _ref1.value : void 0));
    }
    console.log('');
  }
  reporter = new spectacular.BrowserReporter(spectacular.env.runner, [new spectacular.widgets.RunnerProgress]);
  reporter.init();
  spectacular.env.runner.loadEndedAt = new Date();
  spectacular.env.runner.specsStartedAt = new Date();
  return spectacular.env.run().fail(function(reason) {
    return console.log(reason.stack);
  });
};
