// Generated by CoffeeScript 1.6.3
var Q, SPECTACULAR_ROOT, colorize, exists, express, findrequire, fs, generateSpecRunner, glob, globPath, globPaths, path, scriptNode, spawn, util, walk,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

Q = require('q');

glob = require('glob');

path = require('path');

express = require('express');

walk = require('walkdir');

util = require('util');

spawn = require('child_process').spawn;

exists = fs.exists || path.exists;

SPECTACULAR_ROOT = path.resolve(__dirname, '..');

colorize = null;

findrequire = function(p, options) {
  var defer, res;
  defer = Q.defer();
  res = [];
  exists(p, function(exist) {
    var emitter;
    if (exist) {
      emitter = walk(p);
      emitter.on('file', function(p, stat) {
        return res.push(path.relative('.', p));
      });
      return emitter.on('end', function() {
        return defer.resolve(res);
      });
    } else {
      return defer.resolve([]);
    }
  });
  return defer.promise;
};

globPath = function(p) {
  var defer;
  defer = Q.defer();
  glob(p, function(err, res) {
    if (err) {
      return defer.reject(err);
    }
    return defer.resolve(res);
  });
  return defer.promise;
};

globPaths = function(globs) {
  var p,
    _this = this;
  return Q.all((function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = globs.length; _i < _len; _i++) {
      p = globs[_i];
      _results.push(globPath(p));
    }
    return _results;
  })()).then(function(results) {
    var paths;
    paths = [];
    results.forEach(function(a) {
      return paths = paths.concat(a);
    });
    return paths;
  });
};

scriptNode = function(path) {
  return "<script type='text/javascript' src='" + path + "'></script>";
};

generateSpecRunner = function(options) {
  var p, paths;
  if (options.verbose) {
    console.log("  " + (colorize('options', 'grey')) + " " + (util.inspect(options)));
  }
  paths = ['assets/js/spectacular.js', 'assets/js/browser_reporter.js'];
  return Q.all((function() {
    var _i, _len, _ref, _results;
    _ref = options.requires;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      _results.push(findrequire(p, options));
    }
    return _results;
  })()).then(function(requires) {
    var collection, f, _i, _j, _len, _len1;
    for (_i = 0, _len = requires.length; _i < _len; _i++) {
      collection = requires[_i];
      for (_j = 0, _len1 = collection.length; _j < _len1; _j++) {
        f = collection[_j];
        if (/(js|coffee)$/.test(f)) {
          paths.push(f);
          if (options.verbose) {
            console.log("  " + (colorize('requires', 'grey')) + " " + f);
          }
        }
      }
    }
    return globPaths(options.globs);
  }).then(function(specs) {
    var f, uniq, v, _i, _j, _len, _len1;
    if (options.verbose) {
      for (_i = 0, _len = specs.length; _i < _len; _i++) {
        f = specs[_i];
        console.log("  " + (colorize('spec', 'grey')) + " " + f);
      }
    }
    paths = paths.concat(specs);
    uniq = [];
    for (_j = 0, _len1 = paths.length; _j < _len1; _j++) {
      v = paths[_j];
      if (__indexOf.call(uniq, v) < 0) {
        uniq.push(v);
      }
    }
    return paths = uniq;
  }).then(function() {
    return globPaths(options.sources);
  }).then(function(sources) {
    var f, p, sourceMapMethods, _i, _len;
    if (options.verbose) {
      for (_i = 0, _len = sources.length; _i < _len; _i++) {
        f = sources[_i];
        console.log("  " + (colorize('source', 'grey')) + " " + f);
      }
    }
    sourceMapMethods = "spectacular.options.hasSourceMap = function(file) {\n  return /\\.coffee$/.test(file);\n};\nspectacular.options.getSourceURLFor = function(file) {\n  return file.replace('.coffee', '.coffee.src')\n};\nspectacular.options.getSourceMapURLFor = function(file) {\n  return file.replace('.coffee', '.map')\n};";
    return "<!doctype html>\n<html>\n  <head>\n    <script>\n      window.spectacular = {\n        options: " + (util.inspect(options)) + ",\n        paths: " + (util.inspect(paths.slice(2))) + "\n      };\n      " + (options.sourceMap ? sourceMapMethods : '') + "\n    </script>\n    <link href='http://fonts.googleapis.com/css?family=Roboto:400,100,300' rel='stylesheet' type='text/css'>\n    <link rel=\"stylesheet\" href=\"assets/css/spectacular.css\"/>\n    <link rel=\"stylesheet\" href=\"http://netdna.bootstrapcdn.com/font-awesome/3.0.2/css/font-awesome.min.css\"/>\n    " + (options.sourceMap ? scriptNode('vendor/source-map.js') : '') + "\n    " + (((function() {
      var _j, _len1, _results;
      _results = [];
      for (_j = 0, _len1 = sources.length; _j < _len1; _j++) {
        p = sources[_j];
        _results.push(scriptNode(p));
      }
      return _results;
    })()).join('\n')) + "\n    " + (((function() {
      var _j, _len1, _results;
      _results = [];
      for (_j = 0, _len1 = paths.length; _j < _len1; _j++) {
        p = paths[_j];
        _results.push(scriptNode(p));
      }
      return _results;
    })()).join('\n')) + "\n  </head>\n  <body></body>\n</html>";
  });
};

exports.run = function(options) {
  var app, defer, phantom, port;
  colorize = function(str, color) {
    if (options.colors) {
      return str[color];
    } else {
      return str;
    }
  };
  defer = Q.defer();
  app = express();
  app.get('/', function(req, res) {
    return generateSpecRunner(options).then(function(html) {
      console.log("  " + (colorize('200', 'green')) + " " + (colorize('GET', 'cyan')) + " /");
      return res.send(html);
    });
  });
  app.use('/assets/js', express["static"](path.resolve(SPECTACULAR_ROOT, 'lib')));
  app.use('/vendor', express["static"](path.resolve(SPECTACULAR_ROOT, 'vendor')));
  app.use('/assets/css', express["static"](path.resolve(SPECTACULAR_ROOT, 'css')));
  app.use('/', function(req, res, next) {
    var compile, compiled, content;
    if (/\.coffee$/.test(req.url) && options.coffee) {
      content = fs.readFileSync(path.resolve("." + req.url)).toString();
      compile = require('coffee-script').compile;
      content = compile(content);
    } else if (/\.coffee\.src$/.test(req.url) && options.coffee) {
      content = fs.readFileSync(path.resolve("." + (req.url.replace('.coffee.src', '.coffee')))).toString();
    } else if (/\.map$/.test(req.url) && options.coffee) {
      content = fs.readFileSync(path.resolve("." + (req.url.replace('.map', '.coffee')))).toString();
      compile = require('coffee-script').compile;
      compiled = compile(content, {
        sourceMap: true
      });
      content = compiled.v3SourceMap;
    } else {
      content = fs.readFileSync(path.resolve("." + req.url)).toString();
    }
    console.log("  " + (colorize('200', 'green')) + " " + (colorize('GET', 'cyan')) + " " + req.url);
    return res.send(content);
  });
  port = process.env.PORT || 5000;
  app.listen(port);
  console.log("  server listening on port " + (port.toString().cyan));
  if (options.phantomjs) {
    console.log("  running tests on phantomjs");
    phantom = spawn(options.phantomjsExecutable, ['./lib/spectacular_phantomjs.js', port]);
    phantom.stdout.on('data', function(data) {
      return util.print(data.toString());
    });
    phantom.stderr.on('data', function(data) {
      return util.print(data.toString());
    });
    phantom.on('exit', function(status) {
      return process.exit(status);
    });
  }
  if (options.slimerjs) {
    console.log("  running tests on slimerjs");
    phantom = spawn(options.slimerjsExecutable, ['./src/spectacular_slimerjs.coffee', port]);
    phantom.stdout.on('data', function(data) {
      return util.print(data.toString());
    });
    phantom.stderr.on('data', function(data) {
      return util.print(data.toString());
    });
    phantom.on('exit', function(status) {
      return process.exit(status);
    });
  }
  return defer.promise;
};
