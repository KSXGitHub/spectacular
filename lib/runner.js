// Generated by CoffeeScript 1.6.2
var Q, Runner, glob, path, util,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Q = require('q');

glob = require('glob');

path = require('path');

util = require('util');

require('colors');

Runner = (function() {
  function Runner(root, options) {
    this.root = root;
    this.options = options;
    this.printResults = __bind(this.printResults, this);
    this.register = __bind(this.register, this);
    this.nextExample = __bind(this.nextExample, this);
    this.executeSpecs = __bind(this.executeSpecs, this);
    this.loadSpecs = __bind(this.loadSpecs, this);
    this.globPaths = __bind(this.globPaths, this);
    this.run = __bind(this.run, this);
    this.results = [];
  }

  Runner.prototype.run = function() {
    var promise;

    return promise = this.globPaths().then(this.loadSpecs).then(this.executeSpecs).then(this.printResults);
  };

  Runner.prototype.globPaths = function() {
    var p,
      _this = this;

    return Q.all((function() {
      var _i, _len, _ref, _results;

      _ref = this.options.globs;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push(this.glob(p));
      }
      return _results;
    }).call(this)).then(function(results) {
      var paths;

      paths = [];
      results.forEach(function(a) {
        return paths = paths.concat(a);
      });
      if (_this.options.verbose) {
        console.log('paths:', paths);
      }
      return paths;
    });
  };

  Runner.prototype.glob = function(path) {
    var defer;

    defer = Q.defer();
    glob(path, function(err, res) {
      if (err) {
        return defer.reject(err);
      }
      return defer.resolve(res);
    });
    return defer.promise;
  };

  Runner.prototype.loadSpecs = function(paths) {
    var p, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = paths.length; _i < _len; _i++) {
      p = paths[_i];
      _results.push(require(path.resolve('.', p)));
    }
    return _results;
  };

  Runner.prototype.executeSpecs = function() {
    var defer, example, _i, _len, _ref;

    this.stack = [];
    _ref = this.root.allExamples;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      example = _ref[_i];
      this.register(example);
    }
    defer = Q.defer();
    this.nextExample(defer);
    return defer.promise;
  };

  Runner.prototype.nextExample = function(defer) {
    var nextExample,
      _this = this;

    if (this.stack.length === 0) {
      return defer.resolve();
    } else {
      nextExample = this.stack.shift();
      global.currentExample = nextExample;
      return nextExample.run().then(function() {
        _this.registerResults(nextExample);
        return _this.nextExample(defer);
      }).fail(function(reason) {
        _this.registerResults(nextExample);
        return _this.nextExample(defer);
      });
    }
  };

  Runner.prototype.register = function(example) {
    return this.stack.push(example);
  };

  Runner.prototype.registerResults = function(example) {
    global.currentExample = null;
    switch (example.result.state) {
      case 'pending':
        util.print('*'.yellow);
        break;
      case 'skipped':
        util.print('x'.magenta);
        break;
      case 'failure':
        util.print('F'.red);
        break;
      case 'success':
        util.print('.'.green);
    }
    return this.results.push(example.result);
  };

  Runner.prototype.hasFailures = function() {
    return this.results.some(function(result) {
      return !result.success;
    });
  };

  Runner.prototype.printResults = function() {
    var expectation, result, _i, _j, _len, _len1, _ref, _ref1;

    console.log('\n');
    if (this.hasFailures()) {
      _ref = this.results;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        result = _ref[_i];
        if (result.state === 'failure') {
          if (result.expectations.length > 0) {
            _ref1 = result.expectations;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              expectation = _ref1[_j];
              if (!expectation.success) {
                console.log(expectation.description.red);
                console.log(expectation.message);
              }
            }
          } else {
            console.log(result.example.description.red);
            console.log(result.example.promise.reason);
          }
        }
      }
      return 1;
    } else {
      console.log("\n\nFinished in ...s");
      return 0;
    }
  };

  return Runner;

})();

module.exports = Runner;
