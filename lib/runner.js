// Generated by CoffeeScript 1.6.2
var Q, Runner, glob, path, util,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Q = require('q');

glob = require('glob');

path = require('path');

util = require('util');

require('colors');

Runner = (function() {
  function Runner(root, options, env) {
    this.root = root;
    this.options = options;
    this.env = env;
    this.printResults = __bind(this.printResults, this);
    this.nextExample = __bind(this.nextExample, this);
    this.executeSpecs = __bind(this.executeSpecs, this);
    this.register = __bind(this.register, this);
    this.registerSpecs = __bind(this.registerSpecs, this);
    this.loadSpecs = __bind(this.loadSpecs, this);
    this.globPaths = __bind(this.globPaths, this);
    this.run = __bind(this.run, this);
    this.results = [];
    this.examples = [];
    this.stack = [];
  }

  Runner.prototype.run = function() {
    var promise,
      _this = this;

    return promise = this.globPaths().then(function(paths) {
      _this.loadStartedAt = new Date();
      return paths;
    }).then(this.loadSpecs).then(function() {
      _this.loadEndedAt = new Date();
      return _this.specsStartedAt = new Date();
    }).then(this.registerSpecs).then(this.executeSpecs).then(function() {
      return _this.specsEndedAt = new Date();
    }).then(this.printResults).then(function() {
      if (_this.hasFailures()) {
        return 1;
      } else {
        return 0;
      }
    });
  };

  Runner.prototype.globPaths = function() {
    var p,
      _this = this;

    return Q.all((function() {
      var _i, _len, _ref, _results;

      _ref = this.options.globs;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push(this.glob(p));
      }
      return _results;
    }).call(this)).then(function(results) {
      var paths;

      paths = [];
      results.forEach(function(a) {
        return paths = paths.concat(a);
      });
      if (_this.options.verbose) {
        console.log('paths:', paths);
      }
      return paths;
    });
  };

  Runner.prototype.glob = function(path) {
    var defer;

    defer = Q.defer();
    glob(path, function(err, res) {
      if (err) {
        return defer.reject(err);
      }
      return defer.resolve(res);
    });
    return defer.promise;
  };

  Runner.prototype.loadSpecs = function(paths) {
    var p, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = paths.length; _i < _len; _i++) {
      p = paths[_i];
      _results.push(require(path.resolve('.', p)));
    }
    return _results;
  };

  Runner.prototype.registerSpecs = function() {
    var example, _i, _len, _ref, _results;

    _ref = this.root.allExamples;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      example = _ref[_i];
      _results.push(this.register(example));
    }
    return _results;
  };

  Runner.prototype.register = function(example) {
    if (example.dependencies.length > 0) {
      this.handleDependencies(example);
    }
    if (this.stack.indexOf(example) === -1) {
      return this.stack.push(example);
    }
  };

  Runner.prototype.handleDependencies = function(example) {
    var dep, dependency, deps, s, _i, _j, _len, _len1, _ref, _ref1;

    deps = [];
    _ref = example.dependencies;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      dep = _ref[_i];
      dependency = this.root.identifiedExamplesMap[dep];
      if (dependency != null) {
        this.checkCircularity(example, dependency);
        deps.push(dependency);
        if (dependency.children != null) {
          _ref1 = dependency.allExamples;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            s = _ref1[_j];
            this.register(s);
          }
        } else {
          this.register(dependency);
        }
      } else {
        throw new Error("unmet dependencicy " + dep + " for example " + example);
      }
    }
    return example.dependenciesMet = function() {
      return deps.every(function(e) {
        return e.succeed;
      });
    };
  };

  Runner.prototype.checkCircularity = function(example, dependency) {
    if (__indexOf.call(example.ancestors, dependency) >= 0) {
      throw new Error("" + example + " can't depends on ancestor " + dependency);
    }
  };

  Runner.prototype.executeSpecs = function() {
    var defer;

    console.log('');
    defer = Q.defer();
    this.nextExample(defer);
    return defer.promise;
  };

  Runner.prototype.nextExample = function(defer) {
    var nextExample,
      _this = this;

    if (this.stack.length === 0) {
      return defer.resolve();
    } else {
      nextExample = this.stack.shift();
      this.env.currentExample = nextExample;
      return nextExample.run().then(function() {
        _this.registerResults(nextExample);
        return _this.nextExample(defer);
      }).fail(function(reason) {
        _this.registerResults(nextExample);
        return _this.nextExample(defer);
      });
    }
  };

  Runner.prototype.registerResults = function(example) {
    this.env.currentExample = null;
    this.printExampleResult(example);
    this.examples.push(example);
    return this.results.push(example.result);
  };

  Runner.prototype.hasFailures = function() {
    return this.results.some(function(result) {
      var _ref;

      return (_ref = result.state) === 'failure' || _ref === 'skipped';
    });
  };

  Runner.prototype.indent = function(string, ind) {
    var i, s, _i, _ref;

    if (ind == null) {
      ind = 4;
    }
    s = '';
    for (i = _i = 0, _ref = ind - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      s = "" + s + " ";
    }
    return "" + s + (string.replace(/\n/g, "\n" + s));
  };

  Runner.prototype.printExampleResult = function(example) {
    if (this.options.noColors) {
      switch (example.result.state) {
        case 'pending':
          return util.print('*');
        case 'skipped':
          return util.print('x');
        case 'failure':
          return util.print('F');
        case 'success':
          return util.print('.');
      }
    } else {
      switch (example.result.state) {
        case 'pending':
          return util.print('*'.yellow);
        case 'skipped':
          return util.print('x'.magenta);
        case 'failure':
          return util.print('F'.red);
        case 'success':
          return util.print('.'.green);
      }
    }
  };

  Runner.prototype.printStack = function(e) {
    return console.log("\n\n" + (e.stack.replace(/^.*\n/, '').grey));
  };

  Runner.prototype.printFailure = function(message) {
    return console.log(("" + ' FAIL '.inverse.bold + " " + message).red);
  };

  Runner.prototype.printMessage = function(message) {
    return console.log("\n" + (this.indent(message)));
  };

  Runner.prototype.printResults = function() {
    var expectation, result, _i, _j, _len, _len1, _ref, _ref1;

    console.log('\n');
    if (this.hasFailures()) {
      _ref = this.results;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        result = _ref[_i];
        if (result.state === 'failure') {
          if (result.expectations.length > 0) {
            _ref1 = result.expectations;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              expectation = _ref1[_j];
              if (!expectation.success) {
                this.printFailure(expectation.description);
                this.printMessage(expectation.message);
                if (this.options.trace) {
                  this.printStack(expectation.trace);
                }
                console.log('\n');
              }
            }
          } else {
            this.printFailure(result.example.description);
            this.printMessage(result.example.examplePromise.reason.message);
            if (this.options.trace) {
              this.printStack(result.example.examplePromise.reason);
            }
            console.log('\n');
          }
        }
      }
    }
    return console.log(this.formatCounters());
  };

  Runner.prototype.formatCounters = function() {
    var assertions, failures, loadDuration, pending, skipped, specsDuration, success;

    success = this.examples.filter(function(e) {
      return e.result.state === 'success';
    }).length;
    failures = this.examples.filter(function(e) {
      return e.result.state === 'failure';
    }).length;
    skipped = this.examples.filter(function(e) {
      return e.result.state === 'skipped';
    }).length;
    pending = this.examples.filter(function(e) {
      return e.result.state === 'pending';
    }).length;
    assertions = this.results.reduce((function(a, b) {
      return a + b.expectations.length;
    }), 0);
    loadDuration = this.formatDuration(this.loadStartedAt, this.loadEndedAt);
    specsDuration = this.formatDuration(this.specsStartedAt, this.specsEndedAt);
    return "Specs loaded in " + loadDuration + "\nFinished in " + specsDuration + "\n" + (this.formatResults(success, failures, skipped, pending, assertions)) + "\n";
  };

  Runner.prototype.formatResults = function(s, f, sk, p, a) {
    return ("" + (this.formatCount(s, 'success', 'success', this.toggle(f, 'green'))) + ",    " + (this.formatCount(a, 'assertion', 'assertions', this.toggle(f, 'green'))) + ",    " + (this.formatCount(f, 'failure', 'failures', this.toggle(f, 'green', 'red'))) + ",    " + (this.formatCount(sk, 'skipped', 'skipped', this.toggle(sk, 'green', 'magenta'))) + ",    " + (this.formatCount(p, 'pending', 'pending', this.toggle(p, 'green', 'yellow'))) + "    ").replace(/\s+/g, ' ');
  };

  Runner.prototype.formatDuration = function(start, end) {
    var duration;

    duration = (end.getMilliseconds() - start.getMilliseconds()) / 1000;
    "" + duration + "s";
    if (!this.options.noColors) {
      duration = duration.yellow;
    }
    return duration;
  };

  Runner.prototype.formatCount = function(value, singular, plural, color) {
    var s;

    s = "" + value + " " + (value === 0 ? plural : value === 1 ? singular : plural);
    if ((color != null) && !this.options.noColors) {
      s = s[color];
    }
    return s;
  };

  Runner.prototype.toggle = function(value, c1, c2) {
    if (value === 0) {
      return c1;
    } else {
      return c2;
    }
  };

  return Runner;

})();

module.exports = Runner;
