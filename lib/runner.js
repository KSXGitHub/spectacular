// Generated by CoffeeScript 1.6.2
var Q, Runner, glob, path, util,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Q = require('q');

glob = require('glob');

path = require('path');

util = require('util');

require('colors');

Runner = (function() {
  function Runner(root, options) {
    this.root = root;
    this.options = options;
    this.printResults = __bind(this.printResults, this);
    this.register = __bind(this.register, this);
    this.nextExample = __bind(this.nextExample, this);
    this.executeSpecs = __bind(this.executeSpecs, this);
    this.loadSpecs = __bind(this.loadSpecs, this);
    this.globPaths = __bind(this.globPaths, this);
    this.run = __bind(this.run, this);
    this.results = [];
    this.examples = [];
    this.stack = [];
  }

  Runner.prototype.run = function() {
    var promise,
      _this = this;

    return promise = this.globPaths().then(function(paths) {
      _this.loadStartedAt = new Date();
      return paths;
    }).then(this.loadSpecs).then(function() {
      _this.loadEndedAt = new Date();
      return _this.specsStartedAt = new Date();
    }).then(this.executeSpecs).then(function() {
      return _this.specsEndedAt = new Date();
    }).then(this.printResults);
  };

  Runner.prototype.globPaths = function() {
    var p,
      _this = this;

    return Q.all((function() {
      var _i, _len, _ref, _results;

      _ref = this.options.globs;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push(this.glob(p));
      }
      return _results;
    }).call(this)).then(function(results) {
      var paths;

      paths = [];
      results.forEach(function(a) {
        return paths = paths.concat(a);
      });
      if (_this.options.verbose) {
        console.log('paths:', paths);
      }
      return paths;
    });
  };

  Runner.prototype.glob = function(path) {
    var defer;

    defer = Q.defer();
    glob(path, function(err, res) {
      if (err) {
        return defer.reject(err);
      }
      return defer.resolve(res);
    });
    return defer.promise;
  };

  Runner.prototype.loadSpecs = function(paths) {
    var p, _i, _len, _results;

    _results = [];
    for (_i = 0, _len = paths.length; _i < _len; _i++) {
      p = paths[_i];
      _results.push(require(path.resolve('.', p)));
    }
    return _results;
  };

  Runner.prototype.executeSpecs = function() {
    var defer, example, _i, _len, _ref;

    console.log('');
    _ref = this.root.allExamples;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      example = _ref[_i];
      this.register(example);
    }
    defer = Q.defer();
    this.nextExample(defer);
    return defer.promise;
  };

  Runner.prototype.nextExample = function(defer) {
    var nextExample,
      _this = this;

    if (this.stack.length === 0) {
      return defer.resolve();
    } else {
      nextExample = this.stack.shift();
      global.currentExample = nextExample;
      return nextExample.run().then(function() {
        _this.registerResults(nextExample);
        return _this.nextExample(defer);
      }).fail(function(reason) {
        _this.registerResults(nextExample);
        return _this.nextExample(defer);
      });
    }
  };

  Runner.prototype.register = function(example) {
    return this.stack.push(example);
  };

  Runner.prototype.registerResults = function(example) {
    global.currentExample = null;
    switch (example.result.state) {
      case 'pending':
        util.print('*'.yellow);
        break;
      case 'skipped':
        util.print('x'.magenta);
        break;
      case 'failure':
        util.print('F'.red);
        break;
      case 'success':
        util.print('.'.green);
    }
    this.examples.push(example);
    return this.results.push(example.result);
  };

  Runner.prototype.hasFailures = function() {
    return this.results.some(function(result) {
      var _ref;

      return (_ref = result.state) === 'failure' || _ref === 'skipped';
    });
  };

  Runner.prototype.indent = function(string, ind) {
    var i, s, _i, _ref;

    if (ind == null) {
      ind = 4;
    }
    s = '';
    for (i = _i = 0, _ref = ind - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      s = "" + s + " ";
    }
    return "" + s + (string.replace(/\n/g, "\n" + s));
  };

  Runner.prototype.printStack = function(e) {
    return console.log("\n\n" + (e.stack.replace(/^.*\n/, '').grey));
  };

  Runner.prototype.printFailure = function(message) {
    return console.log(("" + ' FAIL '.inverse.bold + " " + message).red);
  };

  Runner.prototype.printMessage = function(message) {
    return console.log("\n" + (this.indent(message)));
  };

  Runner.prototype.printResults = function() {
    var expectation, result, _i, _j, _len, _len1, _ref, _ref1;

    console.log('\n');
    if (this.hasFailures()) {
      _ref = this.results;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        result = _ref[_i];
        if (result.state === 'failure') {
          if (result.expectations.length > 0) {
            _ref1 = result.expectations;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              expectation = _ref1[_j];
              if (!expectation.success) {
                this.printFailure(expectation.description);
                this.printMessage(expectation.message);
                if (this.options.trace) {
                  this.printStack(expectation.trace);
                }
                console.log('\n');
              }
            }
          } else {
            this.printFailure(result.example.description);
            this.printMessage(result.example.examplePromise.reason.message);
            if (this.options.trace) {
              this.printStack(result.example.examplePromise.reason);
            }
            console.log('\n');
          }
        }
      }
      this.printDetails();
      return 1;
    } else {
      this.printDetails();
      return 0;
    }
  };

  Runner.prototype.duration = function(start, end) {
    var duration;

    duration = (end.getMilliseconds() - start.getMilliseconds()) / 1000;
    return ("" + duration + "s").yellow;
  };

  Runner.prototype.printDetails = function() {
    var assertions, failures, loadDuration, pending, skipped, specsDuration, success;

    success = this.examples.filter(function(e) {
      return e.result.state === 'success';
    }).length;
    failures = this.examples.filter(function(e) {
      return e.result.state === 'failure';
    }).length;
    skipped = this.examples.filter(function(e) {
      return e.result.state === 'skipped';
    }).length;
    pending = this.examples.filter(function(e) {
      return e.result.state === 'pending';
    }).length;
    assertions = this.results.reduce((function(a, b) {
      return a + b.expectations.length;
    }), 0);
    loadDuration = this.duration(this.loadStartedAt, this.loadEndedAt);
    specsDuration = this.duration(this.specsStartedAt, this.specsEndedAt);
    return console.log("Specs loaded in " + loadDuration + "\nFinished in " + specsDuration + "\n" + (this.formatResults(success, failures, skipped, pending, assertions)) + "\n");
  };

  Runner.prototype.formatResults = function(s, f, sk, p, a) {
    return ("" + (this.formatCount(s, 'success', 'success', this.toggle(f, 'green'))) + ",    " + (this.formatCount(a, 'assertion', 'assertions', this.toggle(f, 'green'))) + ",    " + (this.formatCount(f, 'failure', 'failures', this.toggle(f, 'green', 'red'))) + ",    " + (this.formatCount(sk, 'skipped', 'skipped', this.toggle(sk, 'green', 'red'))) + ",    " + (this.formatCount(p, 'pending', 'pending', this.toggle(p, 'green', 'yellow'))) + "    ").replace(/\s+/g, ' ');
  };

  Runner.prototype.formatCount = function(value, singular, plural, color) {
    var s;

    s = "" + value + " " + (value === 0 ? plural : value === 1 ? singular : plural);
    if (color != null) {
      s = s[color];
    }
    return s;
  };

  Runner.prototype.toggle = function(value, c1, c2) {
    if (value === 0) {
      return c1;
    } else {
      return c2;
    }
  };

  return Runner;

})();

module.exports = Runner;
