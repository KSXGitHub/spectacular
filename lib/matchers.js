// Generated by CoffeeScript 1.6.2
var TAGS, compare, diff, escape, exports, fill, findStateMethodOrProperty, indent, inspect, isArray, isCommonJS, keys, objectDiff, squeeze, stringDiff, uniq,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

isCommonJS = typeof window === "undefined";

if (!isCommonJS) {
  exports = window;
}

TAGS = isCommonJS ? {
  delStart: '\x1B[31m',
  delEnd: '\x1B[39m',
  insStart: '\x1B[32m',
  insEnd: '\x1B[39m',
  space: ''
} : {
  delStart: '<del>',
  delEnd: '</del>',
  insStart: '<ins>',
  insEnd: '</ins>',
  space: ''
};

escape = function(s) {
  var n;

  n = s;
  n = n.replace(/&/g, "&amp;");
  n = n.replace(/</g, "&lt;");
  n = n.replace(/>/g, "&gt;");
  n = n.replace(/"/g, "&quot;");
  return n;
};

diff = function(o, n) {
  var i, ns, os;

  ns = new Object();
  os = new Object();
  i = 0;
  while (i < n.length) {
    if (ns[n[i]] == null) {
      ns[n[i]] = {
        rows: new Array(),
        o: null
      };
    }
    ns[n[i]].rows.push(i);
    i++;
  }
  i = 0;
  while (i < o.length) {
    if (os[o[i]] == null) {
      os[o[i]] = {
        rows: new Array(),
        n: null
      };
    }
    os[o[i]].rows.push(i);
    i++;
  }
  for (i in ns) {
    if (ns[i].rows.length === 1 && typeof os[i] !== "undefined" && os[i].rows.length === 1) {
      n[ns[i].rows[0]] = {
        text: n[ns[i].rows[0]],
        row: os[i].rows[0]
      };
      o[os[i].rows[0]] = {
        text: o[os[i].rows[0]],
        row: ns[i].rows[0]
      };
    }
  }
  i = 0;
  while (i < n.length - 1) {
    if ((n[i].text != null) && (n[i + 1].text == null) && n[i].row + 1 < o.length && (o[n[i].row + 1].text == null) && n[i + 1] === o[n[i].row + 1]) {
      n[i + 1] = {
        text: n[i + 1],
        row: n[i].row + 1
      };
      o[n[i].row + 1] = {
        text: o[n[i].row + 1],
        row: i + 1
      };
    }
    i++;
  }
  i = n.length - 1;
  while (i > 0) {
    if ((n[i].text != null) && (n[i - 1].text == null) && n[i].row > 0 && (o[n[i].row - 1].text == null) && n[i - 1] === o[n[i].row - 1]) {
      n[i - 1] = {
        text: n[i - 1],
        row: n[i].row - 1
      };
      o[n[i].row - 1] = {
        text: o[n[i].row - 1],
        row: i - 1
      };
    }
    i--;
  }
  return {
    o: o,
    n: n
  };
};

stringDiff = function(o, n) {
  var i, nSpace, oSpace, out, pre, str;

  o = o.replace(/\s+$/, "");
  n = n.replace(/\s+$/, "");
  out = diff((o === "" ? [] : o.split(/\s+/)), (n === "" ? [] : n.split(/\s+/)));
  str = "";
  oSpace = o.match(/\s+/g);
  if (oSpace == null) {
    oSpace = [TAGS.space];
  } else {
    oSpace.push(TAGS.space);
  }
  nSpace = n.match(/\s+/g);
  if (nSpace == null) {
    nSpace = [TAGS.space];
  } else {
    nSpace.push(TAGS.space);
  }
  if (out.n.length === 0) {
    i = 0;
    while (i < out.o.length) {
      str += TAGS.delStart + escape(out.o[i]) + oSpace[i] + TAGS.delEnd;
      i++;
    }
  } else {
    if (out.n[0].text == null) {
      n = 0;
      while (n < out.o.length && (out.o[n].text == null)) {
        str += TAGS.delStart + escape(out.o[n]) + oSpace[n] + TAGS.delEnd;
        n++;
      }
    }
    i = 0;
    while (i < out.n.length) {
      if (out.n[i].text == null) {
        str += TAGS.insStart + escape(out.n[i]) + nSpace[i] + TAGS.insEnd;
      } else {
        pre = "";
        n = out.n[i].row + 1;
        while (n < out.o.length && (out.o[n].text == null)) {
          pre += TAGS.delStart + escape(out.o[n]) + oSpace[n] + TAGS.delEnd;
          n++;
        }
        str += "" + out.n[i].text + nSpace[i] + pre;
      }
      i++;
    }
  }
  return str;
};

keys = function(o) {
  var k, _results;

  _results = [];
  for (k in o) {
    _results.push(k);
  }
  return _results;
};

isArray = function(o) {
  return Object.prototype.toString.call(o) === '[object Array]';
};

squeeze = function(s) {
  return s.replace(/\s+/g, ' ');
};

fill = function(l, s) {
  var o;

  if (l == null) {
    l = 4;
  }
  if (s == null) {
    s = ' ';
  }
  o = '';
  while (o.length < l) {
    o = "" + o + s;
  }
  return o;
};

indent = function(string, ind) {
  var s;

  if (ind == null) {
    ind = 4;
  }
  s = fill(ind);
  return "" + (string.replace(/\n/g, "\n" + s));
};

uniq = function(arr) {
  var newArr, v, _i, _len;

  newArr = [];
  for (_i = 0, _len = arr.length; _i < _len; _i++) {
    v = arr[_i];
    if (__indexOf.call(newArr, v) < 0) {
      newArr.push(v);
    }
  }
  return newArr;
};

inspect = function(obj, depth) {
  var ind, k, v;

  if (depth == null) {
    depth = 1;
  }
  switch (typeof obj) {
    case 'string':
      return "'" + obj + "'";
    case 'number':
    case 'boolean':
      return "" + obj;
    case 'object':
      ind = fill(depth * 2);
      if (isArray(obj)) {
        if (obj.length === 0) {
          return '[]';
        }
        return "[\n" + (obj.map(function(o) {
          return ind + inspect(o, depth + 1);
        }).join(',\n')) + "\n" + ind.slice(0, -2) + "]";
      } else {
        if (keys(obj).length === 0) {
          return '{}';
        }
        return "{\n" + (((function() {
          var _results;

          _results = [];
          for (k in obj) {
            v = obj[k];
            _results.push("" + ind + k + ": " + (inspect(v, depth + 1)));
          }
          return _results;
        })()).join(',\n')) + "\n" + ind.slice(0, -2) + "}";
      }
      break;
    default:
      return '';
  }
};

objectDiff = function(left, right, depth) {
  var a, allKeys, i, ind, k, key, l, prevInd, s, typeLeft, typeRight;

  if (depth == null) {
    depth = 1;
  }
  typeLeft = typeof left;
  typeRight = typeof right;
  if (typeLeft !== typeRight) {
    return TAGS.delStart + inspect(left, depth) + TAGS.delEnd + TAGS.insStart + inspect(right, depth) + TAGS.insEnd;
  }
  switch (typeLeft) {
    case 'string':
      return inspect(stringDiff(left, right));
    case 'number':
    case 'boolean':
      return stringDiff(left.toString(), right.toString());
    case 'object':
      if (isArray(left) !== isArray(right)) {
        return TAGS.delStart + inspect(left, depth) + TAGS.delEnd + TAGS.insStart + inspect(right, depth) + TAGS.insEnd;
      }
      ind = fill(depth * 2);
      prevInd = fill((depth - 1) * 2);
      if (isArray(left)) {
        l = Math.max(left.length, right.length);
        s = '[';
        a = (function() {
          var _i, _ref, _results;

          _results = [];
          for (i = _i = 0, _ref = l - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            _results.push('\n' + ind + objectDiff(left[i], right[i], depth + 1));
          }
          return _results;
        })();
        return s += a.join(',') + ("\n" + prevInd + "]");
      } else {
        allKeys = uniq(keys(left).concat(keys(right)));
        s = "{";
        a = (function() {
          var _i, _len, _results;

          _results = [];
          for (_i = 0, _len = allKeys.length; _i < _len; _i++) {
            k = allKeys[_i];
            key = k + ': ';
            if (!right[k]) {
              key = TAGS.delStart + key + TAGS.delEnd;
            }
            if (!left[k]) {
              key = TAGS.insStart + key + TAGS.insEnd;
            }
            _results.push('\n' + ind + key + objectDiff(left[k], right[k], depth + 1));
          }
          return _results;
        })();
        return s += a.join(',') + ("\n" + prevInd + "}");
      }
  }
};

compare = function(actual, value, matcher, noMessage) {
  var i, k, v, _i, _len;

  if (noMessage == null) {
    noMessage = false;
  }
  switch (typeof actual) {
    case 'object':
      if (isArray(actual)) {
        if (!noMessage) {
          matcher.message = "" + matcher.message + "\n\n" + (objectDiff(actual, value));
        }
        if (actual.length !== value.length) {
          return false;
        }
        for (i = _i = 0, _len = value.length; _i < _len; i = ++_i) {
          v = value[i];
          if (!compare(actual[i], v, matcher, true)) {
            return false;
          }
        }
        return true;
      } else {
        if (!noMessage) {
          matcher.message = "" + matcher.message + "\n\n" + (objectDiff(actual, value));
        }
        if (keys(actual).length !== keys(value).length) {
          return false;
        }
        for (k in value) {
          v = value[k];
          if (!compare(actual[k], v, matcher, true)) {
            return false;
          }
        }
        return true;
      }
      break;
    case 'string':
      if (!noMessage) {
        matcher.message = "" + matcher.message + "\n\n'" + (stringDiff(actual, value)) + "'";
      }
      return actual === value;
    default:
      return actual === value;
  }
};

exports.exist = {
  assert: function(actual, notText) {
    this.description = "should" + notText + " exist";
    this.message = "Expected " + actual + notText + " to exist";
    return actual != null;
  }
};

findStateMethodOrProperty = function(obj, state) {
  var camelizedVersion, snakedVersion;

  camelizedVersion = "is" + (state.capitalize());
  snakedVersion = "is_" + state;
  if (obj[state] != null) {
    return state;
  } else if (obj[camelizedVersion] != null) {
    return camelizedVersion;
  } else if (obj[snakedVersion] != null) {
    return snakedVersion;
  } else {
    return null;
  }
};

exports.be = function(value) {
  return {
    assert: function(actual, notText) {
      var result, state;

      this.description = "should" + notText + " be " + value;
      switch (typeof value) {
        case 'string':
          state = findStateMethodOrProperty(actual, value);
          if (state != null) {
            this.message = "Expected " + actual + "." + state + notText + " to be true but was " + actual[value];
            result = typeof actual[state] === 'function' ? actual[state]() : actual[state];
          } else {
            this.message = "Expected " + actual + " to be " + value + " but the state can't be found";
            result = false;
          }
          return result;
        case 'number':
        case 'boolean':
          this.message = "Expected " + actual + notText + " to be " + value;
          return actual.valueOf() === value;
        default:
          this.description = "should" + notText + " be " + (squeeze(inspect(value)));
          this.message = "Expected " + (inspect(actual)) + notText + " to be " + (inspect(value));
          return actual === value;
      }
    }
  };
};

exports.equal = function(value) {
  return {
    assert: function(actual, notText) {
      this.description = "should" + notText + " be equal to " + (squeeze(inspect(value)));
      this.message = "Expected " + (inspect(actual)) + notText + " to be equal to " + (inspect(value));
      return compare(actual, value, this);
    }
  };
};

exports.match = function(re) {
  return {
    assert: function(actual, notText) {
      this.description = "should" + notText + " match " + re;
      this.message = "Expected '" + actual + "'" + notText + " to match " + re;
      return re.test(actual);
    }
  };
};

exports.throwAnError = function(message) {
  return {
    assert: function(actual, notText) {
      var error, msg;

      msg = message != null ? " with message " + message : '';
      if (this["arguments"] != null) {
        msg += " with arguments " + (inspect(this["arguments"]));
      }
      this.description = "should" + notText + " throw an error" + msg;
      try {
        if (this["arguments"] != null) {
          actual.apply(this.context, this["arguments"]);
        } else {
          actual.call(this.context);
        }
      } catch (_error) {
        error = _error;
      }
      this.message = "Expected" + notText + " to throw an error" + msg + " but was " + error;
      if (message != null) {
        return (error != null) && message.test(error.message);
      } else {
        return error != null;
      }
    },
    "with": function() {
      var arguments, _arguments;

      _arguments = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this["arguments"] = _arguments;
      return this;
    },
    inContext: function(context) {
      this.context = context;
      return this;
    }
  };
};

exports.haveBeenCalled = {
  assert: function(actual, notText) {
    var _this = this;

    if (typeof (actual != null ? actual.spied : void 0) === 'function') {
      if (this["arguments"] != null) {
        this.description = "should have been called with " + (inspect(this["arguments"]));
        this.message = "Expected " + actual.spied + notText + " to have been called with " + (inspect(this["arguments"])) + " but was called with " + actual.argsForCall;
        return actual.argsForCall.length > 0 && actual.argsForCall.some(function(a) {
          return equal(a).assert(_this["arguments"], '');
        });
      } else {
        this.description = "should have been called";
        this.message = "Expected " + actual.spied + notText + " to have been called";
        return actual.argsForCall.length > 0;
      }
    } else {
      this.message = "Expected a spy but it was " + actual;
      return false;
    }
  },
  "with": function() {
    var arguments, _arguments;

    _arguments = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this["arguments"] = _arguments;
    return this;
  }
};
