// Generated by CoffeeScript 1.6.2
var exports, isCommonJS, utils,
  __slice = [].slice;

isCommonJS = typeof window === "undefined";

if (!isCommonJS) {
  exports = window;
}

utils = spectacular.utils;

exports.exist = {
  assert: function(actual, notText) {
    this.description = "should" + notText + " exist";
    this.message = "Expected " + actual + notText + " to exist";
    return actual != null;
  }
};

exports.have = function(count, label) {
  return {
    assert: function(actual, notText) {
      this.description = "should" + notText + " have " + count + " " + label;
      switch (typeof actual) {
        case 'string':
          label || (label = 'chars');
          this.description = "should" + notText + " have " + count + " " + label;
          this.message = "Expected string " + (utils.inspect(actual)) + notText + " to have " + count + " " + label + " but was " + actual.length;
          return actual.length === count;
        case 'object':
          if (utils.isArray(actual)) {
            label || (label = 'items');
            this.description = "should" + notText + " have " + count + " " + label;
            this.message = "Expected array " + (utils.inspect(actual)) + notText + " to have " + count + " " + label + " but was " + actual.length;
            return actual.length === count;
          } else {
            if (label == null) {
              throw new Error("Undefined label in have matcher");
            }
            this.description = "should" + notText + " have " + count + " " + label;
            if (actual[label]) {
              if (utils.isArray(actual[label])) {
                this.message = "Expected object " + (utils.inspect(actual)) + notText + " to have " + count + " " + label + " but was " + actual.length;
                return actual[label].length === count;
              } else {
                this.message = "Expected object " + (utils.inspect(actual)) + notText + " to have " + count + " " + label + " but " + actual[label] + " wasn't an array";
                return false;
              }
            } else {
              this.message = "Expected object " + (utils.inspect(actual)) + notText + " to have " + count + " " + label + " but it didn't have a property named " + label;
              return false;
            }
          }
          break;
        default:
          this.message = "Expected " + (utils.inspect(actual)) + notText + " to have " + count + " " + label + " but it don't have a type that can be handled";
          return false;
      }
    }
  };
};

exports.be = function(value) {
  return {
    assert: function(actual, notText) {
      var result, state;

      this.description = "should" + notText + " be " + value;
      switch (typeof value) {
        case 'string':
          state = utils.findStateMethodOrProperty(actual, value);
          if (state != null) {
            this.message = "Expected " + actual + "." + state + notText + " to be true but was " + actual[value];
            result = typeof actual[state] === 'function' ? actual[state]() : actual[state];
          } else {
            this.message = "Expected " + actual + " to be " + value + " but the state can't be found";
            result = false;
          }
          return result;
        case 'number':
        case 'boolean':
          this.message = "Expected " + actual + notText + " to be " + value;
          return actual.valueOf() === value;
        default:
          this.description = "should" + notText + " be " + (utils.squeeze(utils.inspect(value)));
          this.message = "Expected " + (utils.inspect(actual)) + notText + " to be " + (utils.inspect(value));
          return actual === value;
      }
    }
  };
};

exports.equal = function(value) {
  return {
    assert: function(actual, notText) {
      this.description = "should" + notText + " be equal to " + (utils.squeeze(utils.inspect(value)));
      this.message = "Expected " + (utils.inspect(actual)) + notText + " to be equal to " + (utils.inspect(value));
      return utils.compare(actual, value, this);
    }
  };
};

exports.match = function(re) {
  return {
    assert: function(actual, notText) {
      this.description = "should" + notText + " match " + re;
      this.message = "Expected '" + actual + "'" + notText + " to match " + re;
      return re.test(actual);
    }
  };
};

exports.throwAnError = function(message) {
  return {
    assert: function(actual, notText) {
      var error, msg;

      msg = message != null ? " with message " + message : '';
      if (this["arguments"] != null) {
        msg += " with arguments " + (utils.inspect(this["arguments"]));
      }
      this.description = "should" + notText + " throw an error" + msg;
      try {
        if (this["arguments"] != null) {
          actual.apply(this.context, this["arguments"]);
        } else {
          actual.call(this.context);
        }
      } catch (_error) {
        error = _error;
      }
      this.message = "Expected" + notText + " to throw an error" + msg + " but was " + error;
      if (message != null) {
        return (error != null) && message.test(error.message);
      } else {
        return error != null;
      }
    },
    "with": function() {
      var arguments, _arguments;

      _arguments = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this["arguments"] = _arguments;
      return this;
    },
    inContext: function(context) {
      this.context = context;
      return this;
    }
  };
};

exports.haveBeenCalled = {
  assert: function(actual, notText) {
    var _this = this;

    if (typeof (actual != null ? actual.spied : void 0) === 'function') {
      if (this["arguments"] != null) {
        this.description = "should have been called with " + (utils.inspect(this["arguments"]));
        this.message = "Expected " + actual.spied + notText + " to have been called with " + (utils.inspect(this["arguments"])) + " but was called with " + actual.argsForCall;
        return actual.argsForCall.length > 0 && actual.argsForCall.some(function(a) {
          return equal(a).assert(_this["arguments"], '');
        });
      } else {
        this.description = "should have been called";
        this.message = "Expected " + actual.spied + notText + " to have been called";
        return actual.argsForCall.length > 0;
      }
    } else {
      this.message = "Expected a spy but it was " + actual;
      return false;
    }
  },
  "with": function() {
    var arguments, _arguments;

    _arguments = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this["arguments"] = _arguments;
    return this;
  }
};
