// Generated by CoffeeScript 1.6.2
var compare, diff, difflet, exports, findStateMethodOrProperty, inspect, isCommonJS, objectDiff, squeeze, stringDiff, util;

isCommonJS = typeof window === "undefined";

if (isCommonJS) {
  difflet = require('difflet')({
    indent: 2
  });
  diff = require('node-diff');
  util = require('util');
  inspect = util.inspect;
} else {
  exports = window;
}

exports.exist = {
  assert: function(actual, notText) {
    this.description = "should" + notText + " exist";
    this.message = "Expected " + actual + notText + " to exist";
    return actual != null;
  }
};

findStateMethodOrProperty = function(obj, state) {
  var camelizedVersion, snakedVersion;

  camelizedVersion = "is" + (state.capitalize());
  snakedVersion = "is_" + state;
  if (obj[state] != null) {
    return state;
  } else if (obj[camelizedVersion] != null) {
    return camelizedVersion;
  } else if (obj[snakedVersion] != null) {
    return snakedVersion;
  } else {
    return null;
  }
};

squeeze = function(s) {
  return s.replace(/\s+/g, ' ');
};

exports.be = function(value) {
  return {
    assert: function(actual, notText) {
      var e, result, state;

      this.description = "should" + notText + " be " + value;
      try {
        switch (typeof value) {
          case 'string':
            state = findStateMethodOrProperty(actual, value);
            if (state != null) {
              this.message = squeeze("Expected " + actual + "." + state + notText + "               to be true but was " + actual[value]);
              result = typeof actual[state] === 'function' ? actual[state]() : actual[state];
            } else {
              this.message = squeeze("Expected " + actual + " to be " + value + " but               the state can't be found");
              result = false;
            }
            return result;
          case 'number':
          case 'boolean':
          case 'string':
            this.message = squeeze("Expected " + actual + notText + " to be " + value);
            return actual.valueOf() === value;
          default:
            this.message = squeeze("Expected " + (inspect(actual)) + notText + " to be " + (inspect(value)));
            return actual === value;
        }
      } catch (_error) {
        e = _error;
        return console.log(e);
      }
    }
  };
};

objectDiff = function(left, right) {
  if (isCommonJS) {
    return difflet.compare(left, right);
  } else {
    return '';
  }
};

stringDiff = function(left, right) {
  var res;

  res = diff(left, right);
  if (isCommonJS) {
    res = res.replace('<del>', '\x1B[31m').replace('</del>', '\x1B[39m').replace('<ins>', '\x1B[32m').replace('</ins>', '\x1B[39m');
  }
  return res;
};

compare = function(actual, value, matcher, noMessage) {
  var i, k, v, _i, _len;

  if (noMessage == null) {
    noMessage = false;
  }
  switch (typeof actual) {
    case 'object':
      if (Object.prototype.toString.call(actual) === '[object Array]') {
        for (i = _i = 0, _len = actual.length; _i < _len; i = ++_i) {
          v = actual[i];
          if (!compare(v, value[i], matcher, true)) {
            if (!noMessage) {
              matcher.message = "" + matcher.message + "\n\n" + (objectDiff(actual, value));
            }
            return false;
          }
        }
        return true;
      } else {
        for (k in actual) {
          v = actual[k];
          if (!compare(v, value[k], matcher, true)) {
            if (!noMessage) {
              matcher.message = "" + matcher.message + "\n\n" + (objectDiff(actual, value));
            }
            return false;
          }
        }
        return true;
      }
      break;
    case 'string':
      if (!noMessage) {
        matcher.message = "" + matcher.message + "\n\n" + (stringDiff(actual, value));
      }
      return actual === value;
    default:
      return actual === value;
  }
};

exports.equal = function(value) {
  return {
    assert: function(actual, notText) {
      this.description = "should" + notText + " be equal to " + (inspect(value));
      this.message = "Expected " + (inspect(actual)) + notText + " to be equal to " + (inspect(value));
      return compare(actual, value, this);
    }
  };
};

exports.match = function(re) {
  return {
    assert: function(actual, notText) {
      this.description = "should" + notText + " match " + re;
      this.message = "Expected '" + actual + "'" + notText + " to match " + re;
      return re.test(actual);
    }
  };
};
