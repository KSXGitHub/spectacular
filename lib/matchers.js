// Generated by CoffeeScript 1.6.2
var compare, diff, difflet, exports, findStateMethodOrProperty, inspect, isCommonJS, objectDiff, stringDiff, util, utils,
  __slice = [].slice;

isCommonJS = typeof window === "undefined";

if (isCommonJS) {
  difflet = require('difflet')({
    indent: 2
  });
  diff = require('node-diff');
  util = require('util');
  utils = require('./utils');
  inspect = util.inspect;
} else {
  exports = window;
}

exports.exist = {
  assert: function(actual, notText) {
    this.description = "should" + notText + " exist";
    this.message = "Expected " + actual + notText + " to exist";
    return actual != null;
  }
};

findStateMethodOrProperty = function(obj, state) {
  var camelizedVersion, snakedVersion;

  camelizedVersion = "is" + (state.capitalize());
  snakedVersion = "is_" + state;
  if (obj[state] != null) {
    return state;
  } else if (obj[camelizedVersion] != null) {
    return camelizedVersion;
  } else if (obj[snakedVersion] != null) {
    return snakedVersion;
  } else {
    return null;
  }
};

exports.be = function(value) {
  return {
    assert: function(actual, notText) {
      var result, state;

      this.description = "should" + notText + " be " + value;
      switch (typeof value) {
        case 'string':
          state = findStateMethodOrProperty(actual, value);
          if (state != null) {
            this.message = utils.squeeze("Expected " + actual + "." + state + notText + "             to be true but was " + actual[value]);
            result = typeof actual[state] === 'function' ? actual[state]() : actual[state];
          } else {
            this.message = utils.squeeze("Expected " + actual + " to be " + value + " but             the state can't be found");
            result = false;
          }
          return result;
        case 'number':
        case 'boolean':
        case 'string':
          this.message = utils.squeeze("Expected " + actual + notText + " to be " + value);
          return actual.valueOf() === value;
        default:
          this.message = utils.squeeze("Expected " + (inspect(actual)) + notText + " to be " + (inspect(value)));
          return actual === value;
      }
    }
  };
};

objectDiff = function(left, right) {
  if (isCommonJS) {
    return difflet.compare(left, right);
  } else {
    return '';
  }
};

stringDiff = function(left, right) {
  var res;

  res = diff(left, right);
  if (isCommonJS) {
    res = res.replace('<del>', '\x1B[31m').replace('</del>', '\x1B[39m').replace('<ins>', '\x1B[32m').replace('</ins>', '\x1B[39m');
  }
  return res;
};

compare = function(actual, value, matcher, noMessage) {
  var i, k, v, _i, _len;

  if (noMessage == null) {
    noMessage = false;
  }
  switch (typeof actual) {
    case 'object':
      if (Object.prototype.toString.call(actual) === '[object Array]') {
        for (i = _i = 0, _len = actual.length; _i < _len; i = ++_i) {
          v = actual[i];
          if (!compare(v, value[i], matcher, true)) {
            if (!noMessage) {
              matcher.message = "" + matcher.message + "\n\n" + (objectDiff(actual, value));
            }
            return false;
          }
        }
        return true;
      } else {
        for (k in actual) {
          v = actual[k];
          if (!compare(v, value[k], matcher, true)) {
            if (!noMessage) {
              matcher.message = "" + matcher.message + "\n\n" + (objectDiff(actual, value));
            }
            return false;
          }
        }
        return true;
      }
      break;
    case 'string':
      if (!noMessage) {
        matcher.message = "" + matcher.message + "\n\n" + (stringDiff(actual, value));
      }
      return actual === value;
    default:
      return actual === value;
  }
};

exports.equal = function(value) {
  return {
    assert: function(actual, notText) {
      this.description = "should" + notText + " be equal to " + (inspect(value));
      this.message = "Expected " + (inspect(actual)) + notText + " to be equal to " + (inspect(value));
      return compare(actual, value, this);
    }
  };
};

exports.match = function(re) {
  return {
    assert: function(actual, notText) {
      this.description = "should" + notText + " match " + re;
      this.message = "Expected '" + actual + "'" + notText + " to match " + re;
      return re.test(actual);
    }
  };
};

exports.haveBeenCalled = {
  assert: function(actual, notText) {
    var _this = this;

    if (typeof (actual != null ? actual.spied : void 0) === 'function') {
      if (this["arguments"] != null) {
        this.description = "should have been called with " + this["arguments"];
        this.message = utils.squeeze("Expected " + actual.spied + notText + " to have been called with          " + this["arguments"] + " but was called with " + actual.argsForCall);
        return actual.argsForCall.length > 0 && actual.argsForCall.some(function(a) {
          return equal(a).assert(_this["arguments"], '');
        });
      } else {
        this.description = "should have been called";
        this.message = "Expected " + actual.spied + notText + " to have been called";
        return actual.argsForCall.length > 0;
      }
    } else {
      this.message = "Expected a spy but it was " + actual;
      return false;
    }
  },
  "with": function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this["arguments"] = args;
    return this;
  }
};
