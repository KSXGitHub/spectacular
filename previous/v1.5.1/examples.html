<!DOCTYPE html><html lang="en" class="writing-tests"><head><meta charset="utf-8"><title>Spectacular - Writing Tests</title><link href="http://fonts.googleapis.com/css?family=Roboto:400,100,300" rel="stylesheet" type="text/css"><link rel="stylesheet" href="http://netdna.bootstrapcdn.com/font-awesome/3.2.0/css/font-awesome.min.css"><link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.2.1/pure-min.css"><link href="css/caniuse.css" rel="stylesheet" type="text/css"><link href="css/page.css" rel="stylesheet" type="text/css"><script src="http://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.2/coffee-script.min.js" type="text/javascript"></script></head><body><div id="layout" class="pure-g-r content"><div id="nav" class="pure-u"><a href="#" class="nav-menu-button">Menu</a><header><h1>Spectacular</h1><h2>1.5.1</h2></header><div class="nav-inner"><div class="pure-menu pure-menu-open"><ul><li><a href=".">Home</a></li><li><a href=".#download">Download</a></li><li><a href="./examples.html">Writing Tests</a></li><li><a href="./tools.html">Tests Tools</a></li><li><a href="./extend.html">Extend Spectacular</a></li><li><a href="./tests.html">Online Test Tool</a></li><li><a href="./changelog.html">ChangeLog</a></li><li><a href="./previous.html">Archives</a></li></ul></div><hr><a href="https://github.com/abe33/spectacular" class="fork"><i class="icon-github"></i>Fork me on GitHub</a><div class="badges"><a href="https://travis-ci.org/abe33/spectacular"><img src="https://travis-ci.org/abe33/spectacular.png" alt="Build Status"></a><a href="https://coveralls.io/r/abe33/spectacular?branch=master"><img src="https://coveralls.io/repos/abe33/spectacular/badge.png?branch=master" alt="Coverage Status"></a><a href="https://gemnasium.com/abe33/spectacular"><img src="https://gemnasium.com/abe33/spectacular.png" alt="Dependency Status"></a><a href="http://badge.fury.io/js/spectacular"><img src="https://badge.fury.io/js/spectacular.png" alt="NPM version"></a></div></div></div><div id="list" class="pure-u-1"><nav id="toc"></nav></div><div id="main" class="pure-u-1"><div class="gutter"><h1>Writing Tests</h1><p>The tests in Spectacular are created through two classes, namely <code>Example</code> and <code>ExampleGroup</code>. The <code>Example</code> class represent the actual executed test while <code>ExampleGroup</code> represent a suite of tests and represent the organisation of your tests.</p>
<h2>Examples And ExampleGroups</h2>
<p><code>ExampleGroups</code> are created with either the <code>describe</code> or <code>context</code> methods. New aliases can be created with <code>spectacular.env.createExampleGroupAlias(newName)</code>. The <code>ExampleGroup</code> class has some special properties regarding subjects that are detailed in the <a href="/#Auto-subjects">Auto subjects</a> section.</p>
<p><code>Examples</code> are created with <code>it</code>, <code>the</code> or <code>specify</code>, and new aliases can be created with <code>spectacular.env.createExampleAlias(newName)</code>.</p>
<pre><code class="lang-coffeescript">describe <span class="string">'a group'</span>, -&gt;
  context <span class="string">'a child group'</span>, -&gt;
    specify <span class="string">'an example'</span>, -&gt;
      [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>].should contains <span class="number">1</span></code></pre>
<h2>Examples States</h2>
<p>An example can end with one of the following five state:</p>
<ul>
<li><code>success</code>: When all the expectations were successful.</li>
<li><code>failure</code>: When at least one expectation failed.</li>
<li><code>errored</code>: When an error was raised during the test execution.</li>
<li><code>skipped</code>: When dependencies of a test were not met.</li>
<li><code>pending</code>: When no assertions was made during the test.</li>
</ul>
<h2>Pending Examples</h2>
<p>Examples that doesn&#39;t have a block, or that have a block that doesn&#39;t contains any assertions are considered as <code>pending</code>.</p>
<p>You can force an example to be marked as pending by either calling the pending method in its block or using the <code>xit</code> method.</p>
<pre><code class="lang-coffeescript">it <span class="string">'is pending'</span>

it <span class="string">'is pending'</span>, -&gt;

it <span class="string">'is pending'</span>, -&gt; pending()

xit <span class="string">'is pending'</span>, -&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].should contains <span class="number">1</span></code></pre>
<p>Example groups without block or without examples are also considered as pending. It&#39;s also possible to use either <code>xdescribe</code> or <code>xcontext</code> to mark a group as pending.</p>
<pre><code class="lang-coffeescript">describe <span class="string">'a pending group'</span>

describe <span class="string">'a pending group'</span>, -&gt;

xdescribe <span class="string">'a pending group'</span>, -&gt;
  <span class="comment"># ...</span>

xcontext <span class="string">'a pending context'</span>, -&gt;
  <span class="comment"># ...</span></code></pre>
<h2>Asynchronous Examples</h2>
<p>To create an asynchronous example, just specify an argument to the example
block. A pending promise will be passed to the block. The example can then
either <code>resolve</code> or <code>reject</code> the promise.</p>
<pre><code class="lang-coffeescript">specify <span class="string">'an asynchronous example'</span>, (async) -&gt;
  doSomethingAsync (err, res) -&gt;
    <span class="keyword">return</span> async.reject err <span class="keyword">if</span> err?

    res.should exist
    async.resolve()</code></pre>
<p>In the case the promise is rejected the passed-in reason will be used as failure message.</p>
<p>By default asynchronous example have a timeout limit of 5000ms, but it can be changed using the <code>rejectAfter</code> method of the promise.</p>
<pre><code class="lang-coffeescript">specify <span class="string">'a heavy asynchronous example'</span>, (async) -&gt;
  async.rejectAfter <span class="number">60000</span>, <span class="string">'timeout message'</span>

  <span class="comment"># ...</span></code></pre>
<h2>Conditioned Examples</h2>
<p>Examples can depends on other examples. If all their dependency succeed the example is run, otherwise the example is marked as <code>skipped</code>.</p>
<p>There&#39;s two type of dependencies, an example can either depends on examples from another context:</p>
<pre><code class="lang-coffeescript">describe <span class="string">'first context'</span>, id: <span class="string">'contextId'</span>, -&gt;
  <span class="comment"># ...</span>

describe <span class="string">'depending context'</span>, -&gt;
  dependsOn <span class="string">'contextId'</span>

  <span class="comment"># ...</span></code></pre>
<p>In that case, the <code>depending context</code>&#39;s example will only be run when all the examples in <code>first context</code> succeed.</p>
<p>The other type of dependencies is called cascading dependency, examples in a sub-context will only if the examples in its parent context have all succeed.</p>
<pre><code class="lang-coffeescript">describe <span class="string">'parent context'</span>, -&gt;
  specify <span class="string">'a parent example'</span>, -&gt;
    <span class="comment"># ...</span>

  whenPass -&gt;
    specify <span class="string">'a child example'</span>, -&gt;
      <span class="comment"># ...</span></code></pre>
<p>In that case, the child example will only run if the parent example succeed.</p>
<h2>Examples Subject</h2>
<p>As in RSpecs, example groups can define a subject that will be available in all their examples:</p>
<pre><code class="lang-coffeescript">describe <span class="string">'a subject'</span>, -&gt;
  subject -&gt; {}

  it -&gt; should exist</code></pre>
<p>Some methods such <code>its</code>, <code>itsReturn</code> and <code>itsInstance</code> will test some aspect of a previous subject:</p>
<ul>
<li><code>its &#39;property&#39;</code> will use the content of the specified property as subject for the test block.</li>
<li><code>itsReturn</code> when the current subject is a function will use the value returned by the function as the subject for the test block. It accept two options <code>with</code> and <code>inContext</code> to set respectively the arguments of the call and the call context.</li>
<li><code>itsInstance</code> when the current subject is a function will create an instance and use it as the subject for the test block. It accept a <code>with</code> options to defines the arguments to pass to the constructor.</li>
<li><code>itsInstance &#39;property&#39;</code> when the current subject is a function will create an instance and use the value of the specified property as the subject for the test block.</li>
</ul>
<h2>Auto-subjects</h2>
<p>The <code>describe</code> function can be used to specify an implicit subject for test.</p>
<pre><code class="lang-coffeescript">describe AClass, -&gt;
  withArguments a, b, c

  <span class="comment"># subject here is the class constructor function</span>
  it -&gt; should exist

  <span class="comment"># Automatically create an instance with</span>
  <span class="comment"># the provided parameters as subject</span>
  itsInstance -&gt; should exist

  <span class="comment"># The subject is now AClass.someClassMethod</span>
  describe <span class="string">'.someClassMethod'</span>, -&gt;
    context <span class="string">'called with some parameters'</span>, -&gt;
      <span class="comment"># subject is now the result</span>
      <span class="comment"># of calling AClass.someMethod(10)</span>
      itsReturn <span class="reserved">with</span>: [<span class="number">10</span>], -&gt; should equal <span class="number">20</span>

  describe <span class="string">'::someInstanceMethod'</span>, -&gt;
    context <span class="string">'called with some parameters'</span>, -&gt;
      <span class="comment"># subject is now the result</span>
      <span class="comment"># of calling new Aclass(a,b,c).someInstanceMethod('foo')</span>
      itsReturn <span class="reserved">with</span>: [<span class="string">'foo'</span>], -&gt; should equal <span class="string">'oof'</span></code></pre>
<p>Instance members can also be accessed with a <code>#</code> instead of <code>::</code>.</p>
<h2>Assertions</h2>
<p>Spectacular support two types of assertions, either with the <code>should</code> function or with the <code>expect(...).to</code> syntax. As addition, the <code>Object</code>&#39;s prototype is decorated with a <code>should</code> method, allowing to write <code>10.should equal 10</code>.</p>
<p>The global <code>should</code> function will use the current example subject as actual value to pass to the provided matcher.</p>
<pre><code class="lang-coffeescript">describe <span class="string">'a number'</span>, -&gt;
  subject -&gt; <span class="number">10</span>

  it -&gt; should equal <span class="number">10</span>

  it -&gt; <span class="property">@subject</span>.should equal <span class="number">10</span>

  it -&gt; expect(<span class="property">@subject</span>).to equal <span class="number">10</span></code></pre>
<p>The matcher&#39;s description is used as part of the examples description, for instance the following example:</p>
<pre><code class="lang-coffeescript">specify <span class="string">'the value'</span>, -&gt; should equal <span class="number">10</span></code></pre>
<p>Will produce a description such as:</p>
<pre><code>the value should be equal to 10</code></pre>
<p>The <code>expect</code> function will use the passed-in value as well in the description:</p>
<pre><code class="lang-coffeescript">specify <span class="string">'the value'</span>, -&gt; expect(<span class="number">10</span>).to equal <span class="number">10</span></code></pre>
<p>Gives:</p>
<pre><code>the value 10 should be equal to 10</code></pre>
<p>The inverse of <code>should</code> is <code>shouldnt</code>.
The inverse of <code>expect(...).to</code> is <code>expect(...).not.to</code>.</p>
<h3>Matchers</h3>
<p>The following matchers are provided by Spectacular:</p>
<table cellspacing="0">

  <tr>
    <td><code>exist</code></td>
    <td>Test if the actual value is neither <code>null</code> nor <code>undefined</code>.</td>
  </tr>
  <tr>
    <td><code>equal(value)</code></td>
    <td>Performs a comparison between the actual value and the provided one, objects and arrays are compared by their content and not by their identity. Strings, objects and arrays comparison also includes a diff between the two elements in the matcher message.</td>
  </tr>
    <td><code>be(value)</code></td>
    <td>The <code>be</code> matcher have different behavior according to the type of the provided value.
      <ul>
        <li>If a string is passed, the matcher will look for a property named either <code>value</code>, <code>isValue</code> or <code>is_value</code>, if the property contained a function it will call it, in the end if the value is <code>true</code> the match succeed. It is useful to test the state of an object. For instance you can test the resolution of a promise with <code>@promise.should be &#39;fulfilled&#39;</code>
        </li>
        <li>If the value is an object or an array, the identity of the object is tested using the <code>===</code> operator.</li>
        <li>Boolean and numeric values are test by value like with the <code>equal</code> matcher.</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td><code>beWithin(delta).of(value)</code></td>
    <td>The <code>beWithin</code> matcher checks that the actual is within a delta of your expected value. This is helpful when normal equality expectations do not work well for floating point values.
      <ul><li><code>pi.should beWithin(0.1).of(3.14)</code></li></ul>
    </td>
  </tr>
  <tr>
    <td><code>have(count, property)</code></td>
    <td>The <code>have</code> matcher will behave differently according the type of the actual value:
    <ul>
      <li>If the value is a string, the matcher will test for the length of the string, the <code>property</code> argument will then be used as a description but can be omitted.</li>
      <li>If the value is an array, the matcher will test the length of the array, the <code>property</code> argument will then be used as a description but can be omitted.</li>
      <li>If the value is an object, the matcher will test the length of an array stored in the <code>property</code> property of this object. In that case <code>property</code> is mandatory.</li>
      <li>For any other type the matcher will fail.</li>
    </ul>
    </td>
  </tr>

   <tr>
    <td><code>haveProperty(property, value)</code></td>
    <td>Test if the current subject have a <code>property</code> whose value match <code>value</code>, the <code>value</code> can be a matcher such as <code>object.should haveProperty &#39;foo&#39;, equal 20</code>.</td>
  </tr>

  <tr>
    <td><code>haveAttribute(attribute, value)</code></td>
    <td>Test if the current subject have an <code>attribute</code> whose value match <code>value</code>, the <code>value can be a matcher such as</code>node.should haveAttribute &#39;foo&#39;, equal 20<code>.&lt;/td&gt;
  &lt;/tr&gt;

  &lt;tr&gt;
    &lt;td&gt;</code>haveClass(cls)<code>&lt;/td&gt;
    &lt;td&gt;Test if the current subject have the given</code>cls<code>in its</code>class<code>attribute.&lt;/td&gt;
  &lt;/tr&gt;

  &lt;tr&gt;
    &lt;td&gt;</code>haveSelector(selector)<code>&lt;/td&gt;
    &lt;td&gt;Will test a</code>Node<code>or a</code>NodeList<code>with the given CSS query.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;</code>match(expression)<code>&lt;/td&gt;
    &lt;td&gt;Will either test a regexp or a string against a string or a DOM expression against a node or a node list.
      &lt;ul&gt;
        &lt;li&gt;</code>&#39;string&#39;.should match /string/<code>&lt;/li&gt;
        &lt;li&gt;</code>&#39;string&#39;.should match &#39;string&#39;<code>&lt;/li&gt;
        &lt;li&gt;</code>node.should match @domExpression<code>&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;</code>contains(element)<code>&lt;/td&gt;
    &lt;td&gt;Will either test the presence of</code>element<code>in an array or a dom expression in a node or a node list.&lt;/td&gt;
  &lt;tr&gt;
    &lt;td&gt;</code>throwAnError(message)<code>&lt;/td&gt;
    &lt;td&gt;
      When the subject is a function it will test that the function throw an error. The</code>message<code>argument will be used to test the error message. If no message is passed only the throw of an error is tested.

      The</code>throwAnError<code>matcher provides additional methods to specify the arguments and context of the call:
      &lt;ul&gt;
        &lt;li&gt;</code>throwAnError(message).with(arguments...)<code>: Sets the arguments to use for the call and return the matcher.&lt;/li&gt;
        &lt;li&gt;</code>throwAnError(message).inContext(context)<code>: Sets the context of the call and return the matcher.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;</code>haveBeenCalled<code>&lt;/td&gt;
    &lt;td&gt;
      When the subject is a spy it will test for previous calls on this spy.

      The arguments passed to the spy can be tested with the following syntax:
      &lt;ul&gt;&lt;li&gt;</code>haveBeenCalled.with(arguments...)`:</li></ul>
    </td>
  </tr>
</table>

<h2>Before &amp; After Hooks</h2>
<p>Before and after hooks are defined in a per context basis.</p>
<pre><code class="lang-coffeescript">describe <span class="string">'context with hooks'</span>, -&gt;
  before -&gt; fs.writeFileSync <span class="string">'path'</span>, <span class="string">'content'</span>
  after -&gt; fs.unlink <span class="string">'path'</span>

  specify <span class="string">'an example'</span>, -&gt;
    fs.readFileSync(<span class="string">'path'</span>).should exist</code></pre>
<p>Hooks can be asynchronous in the same way as example:</p>
<pre><code class="lang-coffeescript">describe <span class="string">'context with hooks'</span>, -&gt;
  before (async) -&gt; fs.writeFile <span class="string">'path'</span>, <span class="string">'content'</span>, (err) -&gt;
    <span class="keyword">return</span> async.reject err <span class="keyword">if</span> err?
    async.resolve()

  after (async) -&gt;
    fs.unlink <span class="string">'path'</span>
    async.resolve()

  specify <span class="string">'an example'</span>, (async) -&gt;
    fs.readFile <span class="string">'path'</span>, (err, content) -&gt;
      <span class="keyword">return</span> async.reject err <span class="keyword">if</span> err?

      content.should exist
      async.resolve()</code></pre>
<p>The same rules apply for hooks than for examples, meaning that a rejected promise end with the example marked as <code>errored</code>, and the timeout can be changed using the <code>rejectAfter</code> method of the promise.</p>
</div></div><script src="js/caniuse.js" type="text/javascript"></script></div><script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js" type="text/javascript"></script><script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/highlight.min.js" type="text/javascript"></script><script src="js/pages.js" type="text/javascript"></script></body></html>